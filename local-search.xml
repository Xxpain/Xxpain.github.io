<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java 目前的发展</title>
    <link href="/2023/06/08/java-future/"/>
    <url>/2023/06/08/java-future/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>作为一个 java 开发者自然是对 java 语言发展很关心的，虽然工作万年 jdk 8，但是新版本的 jdk 用到生产环境应该也不会远了。</p><h2 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h2><p>从 2017 年开始，JDK 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。所以 jdk 的版本号也是飞速的开始上涨，<del>看着有要跟上 chrome 114.0.5735.110 版本号 的节奏</del></p><p>因为 jdk 版本号刷的太快了，就主要介绍 lts 版本</p><p>中间主要更新重点是这些项目</p><p>Loom，Valhalla，Amber，Panama</p><ul><li><p>amber ，直译是琥珀，旨在提升 Java 的语言表现力，其中 var 关键字、text block 、record class 、sealed class 和模式匹配等，就是这个项目的产品，它们大多都以上线(released)。</p></li><li><p>loom ，直译是织布机，为 Java 引入虚拟线程（与协程进行区分），有点类似 goroutine ，完全由 JVM 管理和调度的用户态轻量级线程，完全与现有的 thread api 兼容。</p></li><li><p>panama ，取巴拿马运河沟通大西洋和太平洋之意，旨在提升 Java 调用外部语言 /接口等的能力，Java16 的向量化 API 源自于此。</p></li><li><p>valhalla ，直译是北欧神话中的英灵殿，为 Java 引入值类型和用户定义的基本量类型。</p></li></ul><h3 id="jdk-11"><a href="#jdk-11" class="headerlink" title="jdk 11"></a>jdk 11</h3><h4 id="本地变量类型推断"><a href="#本地变量类型推断" class="headerlink" title="本地变量类型推断"></a>本地变量类型推断</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LocalVar.java</span><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalVar</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Arrays.asList(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;Ruby&quot;</span>)<br>            .forEach((<span class="hljs-keyword">var</span> s) -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + s);<br>            &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量类型推断就是左边的类型直接使用 <strong>var</strong> 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型。</p><h4 id="字符串加强"><a href="#字符串加强" class="headerlink" title="字符串加强"></a>字符串加强</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 判断字符串是否为空白<br><span class="hljs-string">&quot; &quot;</span>.isBlank(); <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 去除首尾空格<br><span class="hljs-string">&quot; Javastack &quot;</span>.strip(); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Javastack&quot;</span><br><span class="hljs-regexp">//</span> 去除尾部空格<br><span class="hljs-string">&quot; Javastack &quot;</span>.stripTrailing(); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot; Javastack&quot;</span><br><span class="hljs-regexp">//</span> 去除首部空格<br><span class="hljs-string">&quot; Javastack &quot;</span>.stripLeading(); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Javastack &quot;</span><br><span class="hljs-regexp">//</span> 复制字符串<br><span class="hljs-string">&quot;Java&quot;</span>.repeat(<span class="hljs-number">3</span>);<span class="hljs-regexp">//</span> <span class="hljs-string">&quot;JavaJavaJava&quot;</span><br><span class="hljs-regexp">//</span> 行数统计<br><span class="hljs-string">&quot;A\nB\nC&quot;</span>.lines().count(); <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="集合加强"><a href="#集合加强" class="headerlink" title="集合加强"></a>集合加强</h4><p>自 Java 9 开始，<a href="https://www.baidu.com/s?wd=Jdk&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">Jdk</a> 里面为集合（List/ Set/ Map）都添加了 of 和 copyOf 方法，它们两个都用来创建不可变的集合.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">List</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>var copy = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">List</span>.</span></span>copy<span class="hljs-constructor">Of(<span class="hljs-params">list</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-built_in">list</span><span class="hljs-operator"> == </span>copy); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="Stream-加强"><a href="#Stream-加强" class="headerlink" title="Stream 加强"></a>Stream 加强</h4><p>Stream 是 Java 8 中的新特性，Java 9 开始对 Stream 增加了以下 4 个新方法。</p> <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Nullable(<span class="hljs-params">null</span>)</span>.count<span class="hljs-literal">()</span>; <span class="hljs-comment">// 0</span><br><br><br><span class="hljs-comment">//增加 takeWhile 和 dropWhile 方法</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>.take<span class="hljs-constructor">While(<span class="hljs-params">n</span> -&gt; <span class="hljs-params">n</span> &lt; 3)</span><br>.collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>); <span class="hljs-comment">// [1, 2]</span><br><br><br>从开始计算，当 n &lt; <span class="hljs-number">3</span> 时就截止。<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>.drop<span class="hljs-constructor">While(<span class="hljs-params">n</span> -&gt; <span class="hljs-params">n</span> &lt; 3)</span><br>.collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>); <span class="hljs-comment">// [3, 2, 1]</span><br></code></pre></td></tr></table></figure><h4 id="HTTP-Client-API"><a href="#HTTP-Client-API" class="headerlink" title="HTTP Client API"></a>HTTP Client API</h4><p>这是 Java 9 开始引入的一个处理 HTTP 请求的的孵化 HTTP Client API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在 java.net 包中找到这个 API。</p><p>限于篇幅，还有很多更新也比较重要，就不一一介绍了。</p><h3 id="jdk-17"><a href="#jdk-17" class="headerlink" title="jdk 17"></a>jdk 17</h3><p>这个版本是想当重量级，因为 spring boot 3 最低支持版本就是 jdk 17，虽然刚开始很多人对 spring 如此激进的跨版本升级有很多疑问，但是我觉得是一件很好的事情，由 spring 牵头的话，国内万年 jdk 8 的场面应该是可以改变一些了。</p><p>以下是 jdk 17 相关新特性</p><ul><li>306：Restore Always-Strict Floating-PointSemantics / 恢复始终严格的浮点语义</li><li>356：Enhanced Pseudo-Random Number Generators / 增强型伪随机数发生器</li><li>382：New macOS Rendering Pipeline / 新的 macOS 渲染管道</li><li>391：macOS/AArch64 Port / macOS/AArch64 平台支持</li><li>398：Deprecate the Applet API for Removal / 弃用即将删除的Applet API</li><li>403：Strongly Encapsulate JDK Internals / 强封装JDK的内部API</li><li>406：Pattern Matching for switch（Preview） / Switch模式匹配（预览）</li><li>407：Remove RMI Activation / 删除 RMI 激活机制</li><li>409：Sealed Classes / 密封类</li><li>410：Remove the Experimental AOT and JIT Compiler / 删除实验性 AOT 和 JIT 编译器</li><li>411：Deprecate the Security Manager For Removal / 弃用即将删除的安全管理器</li><li>412：Foreign Function &amp; Memory API（Incubator） / 外部函数和内存 API（孵化器）</li><li>414：Vector API （Second Incubator） / 矢量 API（二次孵化）</li><li>415：Context-Specific Deserialization Filters / 特定于上下文的反序列化过滤器</li></ul><p>总的来时更新不是特别多，但是开发体验上跟 jdk 8 比已经很舒服了。</p><p>而且新能上比 jdk 8 也是优秀许多的。</p><p>17版本默认 gc 回收器也更改为了 g1 垃圾回收器。</p><h4 id="jdk-21"><a href="#jdk-21" class="headerlink" title="jdk 21"></a>jdk 21</h4><p>这个版本距离生产环境估计还是比较远的。</p><ul><li>JEP 429：作用域值（孵化器）</li><li>JEP 434：外部函数和内存 API（第二次预览）</li><li>JEP 436：虚拟线程（第二次预览）</li><li>JEP 437：结构化并发（第二个孵化器）</li><li>JEP 438: Vector API (第五个孵化器)</li><li>JEP 432：记录模式（第二次预览）</li><li>JEP 433：switch 模式匹配（第四次预览）</li></ul><p>不过里面最值得关注的就是 java 版本的虚拟线程了。</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><h4 id="spring-boot3"><a href="#spring-boot3" class="headerlink" title="spring boot3"></a>spring boot3</h4><p>上面已经说过，spring boot 3一口气把 jdk 版本升到了 17，并且支持了 AOT，不过是基于 Graalvm 实现的。个人体验过了一些，只能说目前 AOT 只适用于个人项目玩玩，生产环境可能会损失很多性能，而且项目编译成 AOT 时，非常的慢。</p><h4 id="quarkus"><a href="#quarkus" class="headerlink" title="quarkus"></a>quarkus</h4><p>Quarkus是一个全栈Kubernetes原生Java框架，用于Java虚拟机(JVM)和原生编译，专门针对容器优化Java，使其成为无服务器、云和Kubernete环境的有效平台。</p><p>个人体验了一下，在国内的话生态什么的肯定还是不如 spring ，不过有竞争，也可以让 spring 继续改善。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 AIGC</title>
    <link href="/2023/05/23/ai-think/"/>
    <url>/2023/05/23/ai-think/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>chatGPT 已经火出圈快半年了，作为一个行业相关者，当然也是一直在关注 着 AIGC 相关事物。</p><h3 id="GitHub-Copilot-初见"><a href="#GitHub-Copilot-初见" class="headerlink" title="GitHub Copilot 初见"></a>GitHub Copilot 初见</h3><p>记得去年在 8 月份吧，逛 v2ex 看到可以申请测试体验，马上就上 github 申请了，半月过去就通过了，</p><p>而且还有 idea 插件支持，作为一个 javaer，整一个就是欣喜若狂，马上安装试用。</p><h4 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h4><p>上一秒你还觉得，卧槽它怎么知道我想这么写。</p><p>下一秒你又不忍感叹，卧槽这个制杖怎么想这么写？</p><p>当时感觉还是很震撼的，不过马上就能看到一些人在讨论微软 &amp; github 是否滥用开源代码训练他们的 ai 模型的版权问题。</p><p>后面因为和 idea 自动提示冲突比较多 &amp;&amp; 微软要开始收费，就卸载插件了。</p><h3 id="Stable-Diffusion-AI-绘画"><a href="#Stable-Diffusion-AI-绘画" class="headerlink" title="Stable Diffusion AI 绘画"></a>Stable Diffusion AI 绘画</h3><p>当时是逛推特，看到一组特别精美的 coser 照片，正当我感叹为何世上有如此完美的脸庞和身材。</p><p>结果看到评论区有人提醒是 AI 绘画。然后仔细一看发现手和膝盖确实存在很多明显不自然处。</p><h4 id="流行-amp-爆发"><a href="#流行-amp-爆发" class="headerlink" title="流行 &amp; 爆发"></a>流行 &amp; 爆发</h4><p>Stable Diffusion 开源后，AI绘画如雨后春笋般出来了，</p><p>NovelAI 使用开源的数据训练出来的专门画二次元 anime 模型和 naifu 和被黑客泄露，</p><p>这也成了后面一些二次元画师声讨 AI 绘画的起火点，也是针对版权问题进行疯狂拉扯。</p><h3 id="chatGPT"><a href="#chatGPT" class="headerlink" title="chatGPT"></a>chatGPT</h3><p>没错还是在 v2ex 看到有人说 openai 推出了一个很智能的对话 ai，当时还没有火出圈，</p><p>但是我本着什 么都要试一下的好奇心，用打码平台注册了个账号（<del>中国手机号不支持 + ip 不支持，属实是难受</del>）</p><h4 id="体验-1"><a href="#体验-1" class="headerlink" title="体验"></a>体验</h4><p>相比于 github copilot，chatGPT 带给我震撼明显是更大的，因为 chatGPT 的泛用性明显比前一个更高.</p><p>可以用于生成文本内容，例如新闻摘要，简化复杂的信息，以便用户快速了解最重要的信息。它也可</p><p>以生成小说、故事等文本内容，并且具有很高的语言表现力和创意性。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>当然 chatGPT 只是语言模型，距离强人工智能还很远，比如数学运算，一些逻辑推理题，</p><p>它会比较明显的胡说八道。期待强人工智能到来的一天。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>作为一个码农，chatGPT 的出现让我肯定也担忧，不过相较于悲观起来，</p><p>我倒很期待后期计算机开发由 ai 主导的情况下会催化出哪些工作岗位，</p><p>毕竟最好不要和 ai 直接竞争工作，而是把它当做工具成为那个操控者。</p><hr><h2 id="AI-美化"><a href="#AI-美化" class="headerlink" title="AI 美化"></a>AI 美化</h2><p>试着用 AI 美化一下文章，发现比自己文笔还是好的多的，😂</p><hr><p>在过去的几个月中，我一直在关注 AIGC 相关的事物，其中 chatGPT 和 Stable Diffusion AI 绘画 两个项目引起了我的注意。下面是我对这些项目的体验和思考：</p><h3 id="GitHub-Copilot"><a href="#GitHub-Copilot" class="headerlink" title="GitHub Copilot"></a>GitHub Copilot</h3><p>我在去年 8 月份得知 GitHub Copilot，并且申请了测试体验。它是一个能够为编程提供提示和建议的人工智能工具。作为一名 Java 开发者，我非常高兴有这样一个工具来帮助我。当我使用它时，感觉它对我的编程经验有很大的帮助。不过，随着时间推移，一些人开始讨论微软和 GitHub 是否滥用开源代码来训练他们的 AI 模型的版权问题。此外，由于与 IntelliJ IDEA 的自动提示冲突比较多并且微软要开始收费，我最终卸载了该插件。</p><h3 id="Stable-Diffusion-AI-绘画-1"><a href="#Stable-Diffusion-AI-绘画-1" class="headerlink" title="Stable Diffusion AI 绘画"></a>Stable Diffusion AI 绘画</h3><p>我在 Twitter 上看到了一组特别精美的 coser 照片，后来发现这些照片是由 AI 绘画生成的。然而，在这些照片中，手和膝盖等部位存在明显的不自然之处。Stable Diffusion AI 绘画 项目开源后，AI 绘画如雨后春笋般出现了。 NovelAI 使用开源的数据训练出了专门画二次元 anime 模型和 naifu，并被黑客泄露，这也成为了后面一些二次元画师声讨 AI 绘画的起点，也是针对版权问题进行疯狂拉扯。</p><h3 id="chatGPT-1"><a href="#chatGPT-1" class="headerlink" title="chatGPT"></a>chatGPT</h3><p>我在 v2ex 上看到有人说 OpenAI 推出了一个很智能的对话 AI。虽然当时它还没有火起来，但我还是用打码平台注册了一个账号来体验。与 GitHub Copilot 相比，chatGPT 带给我更大的震撼。因为它的泛用性明显比前一个更高。它可以用于生成文本内容，例如新闻摘要，简化复杂的信息，以便用户快速了解最重要的信息。它也可以生成小说、故事等文本内容，并且具有很高的语言表现力和创意性。不过，chatGPT 只是语言模型，距离强人工智能还有很长的路要走，比如数学运算和一些逻辑推理题，它会胡说八道。作为一个码农，chatGPT 的出现让我肯定也担忧起来。但相较于悲观起来，我倒是很期待后期计算机开发由 AI 主导的情况下又会催化出哪些工作岗位。毕竟最好不要和 AI 直接竞争工作，而是把它当做工具成为那个操控者。</p>]]></content>
    
    
    
    <tags>
      
      <tag>感悟</tag>
      
      <tag>技术</tag>
      
      <tag>ai</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高性能本地缓存库 Caffeine</title>
    <link href="/2023/03/29/Caffeine/"/>
    <url>/2023/03/29/Caffeine/</url>
    
    <content type="html"><![CDATA[<p>很久没写博客了，就总结一下之前项目用过的一些组件 – 本地缓存 Caffeine</p><p>Caffeine是基于Java的一个高性能本地缓存库，由Guava改进而来；</p><p>本文介绍了如何在Java中使用Caffeine缓存，以及如何在SpringBoot中集成Caffeine缓存；</p><p>源代码：</p><ul><li>  <a href="https://github.com/ben-manes/caffeine">https://github.com/ben-manes/caffeine</a></li></ul><br/><span id="more"></span><h1 id="Java高性能缓存库Caffeine"><a href="#Java高性能缓存库Caffeine" class="headerlink" title="Java高性能缓存库Caffeine"></a><strong>Java高性能缓存库Caffeine</strong></h1><h2 id="Caffeine简介"><a href="#Caffeine简介" class="headerlink" title="Caffeine简介"></a><strong>Caffeine简介</strong></h2><p>Caffeine是一个Java高性能的本地缓存库。其官方说明指出，其缓存命中率已经接近最优值。</p><p><font color="#f00"><strong>实际上，Caffeine这样的本地缓存和ConcurrentMap很像：支持并发，并且支持O(1)时间复杂度的数据存取。二者的主要区别在于：</strong></font></p><ul><li>  <font color="#f00"><strong>ConcurrentMap将存储所有存入的数据，直到你显式将其移除；</strong></font></li><li>  <font color="#f00"><strong>Caffeine将通过给定的配置，自动移除“不常用”的数据，以保持内存的合理占用。</strong></font></li></ul><blockquote><p>  因此，一种更好的理解方式是：</p><p>  <strong>Cache是一种带有存储和移除策略的Map</strong><br>  Caffeine提供如下的一些功能：</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">- automatic loading <span class="hljs-keyword">of</span> entries <span class="hljs-keyword">into</span> <span class="hljs-keyword">the</span> cache, optionally asynchronously<br><span class="hljs-comment"># 自动加载条目到缓存中，支持异步加载</span><br>- size-based eviction when <span class="hljs-keyword">a</span> maximum is exceeded based <span class="hljs-keyword">on</span> <span class="hljs-title">frequency</span> <span class="hljs-title">and</span> <span class="hljs-title">recency</span><br><span class="hljs-comment"># 根据频率和最近访问情况，支持将缓存数量设为移除策略</span><br>- <span class="hljs-built_in">time</span>-based expiration <span class="hljs-keyword">of</span> entries, measured since <span class="hljs-keyword">last</span> access <span class="hljs-keyword">or</span> <span class="hljs-keyword">last</span> <span class="hljs-built_in">write</span><br><span class="hljs-comment"># 根据最近访问和修改时间，支持将时间设为移除策略</span><br>- asynchronously refresh when <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> stale request <span class="hljs-keyword">for</span> <span class="hljs-keyword">an</span> entry occurs<br><span class="hljs-comment"># 过期条目再次访问时异步加载</span><br>- <span class="hljs-built_in">keys</span> automatically wrapped <span class="hljs-keyword">in</span> weak references<br><span class="hljs-comment"># key自动包装为弱引用</span><br>- values automatically wrapped <span class="hljs-keyword">in</span> weak <span class="hljs-keyword">or</span> soft references<br><span class="hljs-comment"># value自动包装为弱引用/软引用</span><br>- notification <span class="hljs-keyword">of</span> evicted (<span class="hljs-keyword">or</span> otherwise removed) entries<br><span class="hljs-comment"># 条目移除通知</span><br>- writes propagated <span class="hljs-built_in">to</span> <span class="hljs-keyword">an</span> external resource<br><span class="hljs-comment"># 对外部资源的写入</span><br>- accumulation <span class="hljs-keyword">of</span> cache access statistics<br><span class="hljs-comment"># 累计缓存使用统计</span><br></code></pre></td></tr></table></figure><br/><h2 id="Caffeine基本使用"><a href="#Caffeine基本使用" class="headerlink" title="Caffeine基本使用"></a><strong>Caffeine基本使用</strong></h2><p>在项目中添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>本文基于 2.9.3 版本；</p><br/><h3 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a><strong>缓存类型</strong></h3><p>Caffeine提供了四种类型的Cache，对应着四种加载策略：</p><ul><li>  Cache；</li><li>  LoadingCache；</li><li>  AsyncCache；</li><li>  AsyncLoadingCache；</li></ul><p>下面分别来看；</p><br/><h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a><strong>Cache</strong></h4><p>最普通的一种缓存，无需指定加载方式，需要手动调用<code>put()</code>进行加载；</p><p><strong>需要注意的是：<code>put()</code>方法对于已存在的key将进行覆盖，这点和Map的表现是一致的；</strong></p><p><strong>在获取缓存值时，如果想要在缓存值不存在时，原子地将值写入缓存，则可以调用<code>get(key, k -&gt; value)</code>方法，该方法将避免写入竞争；</strong></p><p>调用<code>invalidate()</code>方法，将手动移除缓存；</p><p>多线程情况下，当使用<code>get(key, k -&gt; value)</code>时，如果有另一个线程同时调用本方法进行竞争，则后一线程会被阻塞，直到前一线程更新缓存完成；</p><p><strong>而若另一线程调用<code>getIfPresent()</code>方法，则会立即返回null，不会被阻塞；</strong></p><p>cache/caffeine/basic/src/main/java/io/github/jasonkayzk/type/CacheDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();<br>        System.out.println(cache.getIfPresent(<span class="hljs-string">&quot;123&quot;</span>)); <span class="hljs-comment">// null</span><br>        System.out.println(cache.get(<span class="hljs-string">&quot;123&quot;</span>, k -&gt; <span class="hljs-string">&quot;456&quot;</span>)); <span class="hljs-comment">// 456</span><br>        System.out.println(cache.getIfPresent(<span class="hljs-string">&quot;123&quot;</span>));    <span class="hljs-comment">// 456</span><br>        cache.put(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;789&quot;</span>);<br>        System.out.println(cache.getIfPresent(<span class="hljs-string">&quot;123&quot;</span>));    <span class="hljs-comment">// 789</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h4 id="LoadingCache"><a href="#LoadingCache" class="headerlink" title="LoadingCache"></a><strong>LoadingCache</strong></h4><p>LoadingCache是一种自动加载的缓存；</p><p><strong>和普通缓存不同的地方在于：当缓存不存在/缓存已过期时，若调用<code>get()</code>方法，则会自动调用<code>CacheLoader.load()</code>方法加载最新值；</strong></p><p><strong>调用<code>getAll()</code>方法将遍历所有的key调用<code>get()</code>，除非实现了<code>CacheLoader.loadAll()</code>方法。</strong></p><p>使用LoadingCache时，需要指定CacheLoader，并实现其中的<code>load()</code>方法供缓存缺失时自动加载。</p><p>多线程情况下，当两个线程同时调用<code>get()</code>，则后一线程将被阻塞，直至前一线程更新缓存完成。</p><p>cache/caffeine/basic/src/main/java/io/github/jasonkayzk/type/LoadingCacheDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadingCacheDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()<br>                .build(<span class="hljs-keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-comment">// 该方法必须实现</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">load</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String k)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;456&quot;</span>;<br>                    &#125;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-comment">// 如果需要批量加载</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-meta">@NonNull</span> <span class="hljs-function">Map&lt;String, String&gt; <span class="hljs-title">loadAll</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Iterable&lt;? extends String&gt; keys)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;<br>                        &#125;;<br>                    &#125;<br>                &#125;);<br>        System.out.println(cache.getIfPresent(<span class="hljs-string">&quot;123&quot;</span>)); <span class="hljs-comment">// null</span><br>        System.out.println(cache.get(<span class="hljs-string">&quot;123&quot;</span>));          <span class="hljs-comment">// 456</span><br>        System.out.println(cache.getAll(Arrays.asList(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;456&quot;</span>)));        <span class="hljs-comment">// Map&lt;String, String&gt;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h4 id="AsyncCache"><a href="#AsyncCache" class="headerlink" title="AsyncCache"></a><strong>AsyncCache</strong></h4><p>AsyncCache是Cache的一个变体，其响应结果均为CompletableFuture，通过这种方式，AsyncCache对异步编程模式进行了适配；</p><p>默认情况下，缓存计算使用<code>ForkJoinPool.commonPool()</code>作为线程池，如果想要指定线程池，则可以覆盖并实现<code>Caffeine.executor(Executor)</code>方法。</p><p><code>synchronous()</code>提供了阻塞直到异步缓存生成完毕的能力，它将以Cache进行返回。</p><p>多线程情况下，当两个线程同时调用<code>get(key, k -&gt; value)</code>，则会返回<strong>同一个CompletableFuture</strong>对象。由于返回结果本身不进行阻塞，可以根据业务设计自行选择阻塞等待或者非阻塞。</p><p>cache/caffeine/basic/src/main/java/io/github/jasonkayzk/type/AsyncCacheDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCacheDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        String key = <span class="hljs-string">&quot;123&quot;</span>;<br>        AsyncCache&lt;String, String&gt; cache = Caffeine.newBuilder().buildAsync();<br>        CompletableFuture&lt;String&gt; completableFuture = cache.get(key, k -&gt; <span class="hljs-string">&quot;456&quot;</span>);<br>        System.out.println(completableFuture.get()); <span class="hljs-comment">// 阻塞，直至缓存更新完成</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h4 id="AsyncLoadingCache"><a href="#AsyncLoadingCache" class="headerlink" title="AsyncLoadingCache"></a><strong>AsyncLoadingCache</strong></h4><p>显然这是Loading Cache和Async Cache的功能组合。AsyncLoadingCache支持以异步的方式，对缓存进行自动加载。</p><p>类似LoadingCache，同样需要指定CacheLoader，并实现其中的<code>load()</code>方法供缓存缺失是自动加载，该方法将自动在<code>ForkJoinPool.commonPool()</code>线程池中提交。如果想要指定Executor，则可以实现<code>AsyncCacheLoader().asyncLoad()</code>方法。</p><p>cache/caffeine/basic/src/main/java/io/github/jasonkayzk/type/AsyncLoadingCacheDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncLoadingCacheDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        String key = <span class="hljs-string">&quot;123&quot;</span>;<br>        AsyncLoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()<br>                .buildAsync(<span class="hljs-keyword">new</span> AsyncCacheLoader&lt;String, String&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-comment">// 自定义线程池加载</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-meta">@NonNull</span> <span class="hljs-function">CompletableFuture&lt;String&gt; <span class="hljs-title">asyncLoad</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String key, <span class="hljs-meta">@NonNull</span> Executor executor)</span> </span>&#123;<br>                        <span class="hljs-keyword">return</span> CompletableFuture.completedFuture(<span class="hljs-string">&quot;456&quot;</span>);<br>                    &#125;<br>                &#125;);<br><span class="hljs-comment">//                .buildAsync(new CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="hljs-comment">//                    @Override</span><br><span class="hljs-comment">//                    // OR，使用默认线程池加载（二者选其一）</span><br><span class="hljs-comment">//                    public String load(@NonNull String key) throws Exception &#123;</span><br><span class="hljs-comment">//                        return &quot;456&quot;;</span><br><span class="hljs-comment">//                    &#125;</span><br><span class="hljs-comment">//                &#125;);</span><br>        CompletableFuture&lt;String&gt; completableFuture = cache.get(key); <span class="hljs-comment">// CompletableFuture&lt;String&gt;</span><br>        System.out.println(completableFuture.get());; <span class="hljs-comment">// 阻塞，直至缓存更新完成</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="驱逐策略"><a href="#驱逐策略" class="headerlink" title="驱逐策略"></a><strong>驱逐策略</strong></h3><p>驱逐策略在创建缓存的时候进行指定；</p><p>常用的有：基于容量的驱逐和基于时间的驱逐；</p><ul><li>  基于容量的驱逐：需要指定缓存容量的最大值；当缓存容量达到最大时，Caffeine将使用LRU策略对缓存进行淘汰；</li><li>  基于时间的驱逐：可以设置在最后访问/写入一个缓存经过指定时间后，自动进行淘汰；</li></ul><p><strong>驱逐策略可以组合使用，任意驱逐策略生效后，该缓存条目即被驱逐；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EvictDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个最大容量为10的缓存</span><br>        Cache&lt;String, String&gt; cache1 = Caffeine.newBuilder().<br>                maximumSize(<span class="hljs-number">10</span>).build();<br>        <span class="hljs-comment">// 创建一个写入5s后过期的缓存</span><br>        Cache&lt;String, String&gt; cache2 = Caffeine.newBuilder().<br>                expireAfterWrite(<span class="hljs-number">5</span>, TimeUnit.SECONDS).build();<br>        <span class="hljs-comment">// 创建一个访问1s后过期的缓存</span><br>        Cache&lt;String, String&gt; cache3 = Caffeine.newBuilder().<br>                expireAfterAccess(<span class="hljs-number">1</span>, TimeUnit.SECONDS).build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="刷新机制"><a href="#刷新机制" class="headerlink" title="刷新机制"></a><strong>刷新机制</strong></h3><p>试想这样一种情况：当缓存运行过程中，有些缓存值我们需要定期进行刷新，以确保信息可以正确被同步到缓存中来；</p><p>我们当然可以使用基于时间的驱逐策略<code>expireAfterWrite()</code>，但带来的问题是：一旦缓存过期，下次重新加载缓存时将使得调用线程处于阻塞状态；</p><p>而使用刷新机制<code>refreshAfterWrite()</code>，Caffeine将在key允许刷新后的首次访问时，立即返回旧值，同时异步地对缓存值进行刷新，这使得调用方不至于因为缓存驱逐而被阻塞；</p><p><strong>需要注意的是：刷新机制只支持LoadingCache和AsyncLoadingCache；</strong></p><p>通过覆写<code>CacheLoader.reload()</code>方法，将在刷新时使得旧缓存值参与其中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefreshDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LoadingCache&lt;String, String&gt; cache1 = Caffeine.newBuilder().<br>                refreshAfterWrite(<span class="hljs-number">10</span>, TimeUnit.MINUTES).<br>                build(RefreshDemo::create);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">create</span><span class="hljs-params">(String k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a><strong>统计</strong></h3><p>Caffeine内置了数据收集功能，通过<code>Caffeine.recordStats()</code>方法，可以打开数据收集；</p><p>这样<code>Cache.stats()</code>方法将会返回当前缓存的一些统计指标，例如：</p><ul><li>  <code>hitRate</code>：查询缓存的命中率</li><li>  <code>evictionCount</code>：被驱逐的缓存数量</li><li>  <code>averageLoadPenalty</code>：新值被载入的平均耗时</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecordDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取统计指标</span><br>        Cache&lt;String, String&gt; cache = Caffeine.newBuilder().<br>                recordStats().build();<br>        System.out.println(cache.stats());<br>        System.out.println(cache.estimatedSize());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">CacheStats&#123;<span class="hljs-attribute">hitCount</span>=0, <span class="hljs-attribute">missCount</span>=0, <span class="hljs-attribute">loadSuccessCount</span>=0, <span class="hljs-attribute">loadFailureCount</span>=0, <span class="hljs-attribute">totalLoadTime</span>=0, <span class="hljs-attribute">evictionCount</span>=0, <span class="hljs-attribute">evictionWeight</span>=0&#125;<br>0<br></code></pre></td></tr></table></figure><br/><h2 id="SpringBoot中集成Caffeine"><a href="#SpringBoot中集成Caffeine" class="headerlink" title="SpringBoot中集成Caffeine"></a><strong>SpringBoot中集成Caffeine</strong></h2><h3 id="SpringBoot缓存管理器"><a href="#SpringBoot缓存管理器" class="headerlink" title="SpringBoot缓存管理器"></a><strong>SpringBoot缓存管理器</strong></h3><p>Spring从3.1开始就引入了对Cache的支持。定义了<code>org.springframework.cache.Cache</code>和<code>org.springframework.cache.CacheManager</code>接口，来统一不同的缓存技术，并支持使用<code>JCache(JSR-107)</code>注解来简化开发。</p><ul><li>  Cache接口包括了缓存的各种操作集合，实际操作缓存时，即通过这些接口进行操作。</li><li>  Cache接口下Spring提供了各种xxxCache的实现。由于官方从SpringBoot 2.x后，将Caffeine代替Guava作为默认的缓存组件，因此这里我们需要用到的就是<code>CaffeineCache</code>这个类。如果需要自定义Cache实现，只需要实现Cache接口即可。</li><li>  CacheManager 定义了创建、配置、获取、管理和控制多个唯一命名的 Cache。这些 Cache 存在于 CacheManager 的上下文中。</li></ul><p>创建一个缓存管理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">()</span> </span>&#123;<br>    SimpleCacheManager cacheManager = <span class="hljs-keyword">new</span> SimpleCacheManager();<br>    ArrayList&lt;CaffeineCache&gt; caches = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">// String cacheName(): 创建缓存名称</span><br>    <span class="hljs-comment">// Cache&lt;Object, Object&gt; generateCache(): 创建一个Caffeine缓存</span><br>    caches.add(<span class="hljs-keyword">new</span> CaffeineCache(cacheName(), generateCache()));<br>    cacheManager.setCaches(caches);<br>    <span class="hljs-keyword">return</span> cacheManager;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用这种方式，可以同时在缓存管理器中添加多个缓存。需要注意的是，<strong>SimpleCacheManager只能使用Cache和LoadingCache，异步缓存将无法支持</strong>。</p><br/><h3 id="使用-Cacheable相关注解"><a href="#使用-Cacheable相关注解" class="headerlink" title="使用@Cacheable相关注解"></a><strong>使用@Cacheable相关注解</strong></h3><h4 id="Cacheable相关注解"><a href="#Cacheable相关注解" class="headerlink" title="@Cacheable相关注解"></a><strong>@Cacheable相关注解</strong></h4><p>添加完成缓存管理器后，我们可以方便地使用<code>@Cacheable</code>相关注解对缓存进行管理了。为了使用该注解，需要引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>和@Cacheable相关的常用的注解包括：</p><ul><li>  <code>@Cacheable</code>：表示该方法支持缓存。当调用被注解的方法时，如果对应的键已经存在缓存，则不再执行方法体，而从缓存中直接返回。当方法返回null时，将不进行缓存操作。</li><li>  <code>@CachePut</code>：表示执行该方法后，其值将作为最新结果更新到缓存中。<strong>每次都会执行该方法</strong>。</li><li>  <code>@CacheEvict</code>：表示执行该方法后，将触发缓存清除操作。</li><li>  <code>@Caching</code>：用于组合前三个注解，例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Caching(cacheable = @Cacheable(&quot;users&quot;),</span><br><span class="hljs-meta">         evict = &#123;@CacheEvict(&quot;cache2&quot;), @CacheEvict(value = &quot;cache3&quot;, allEntries = true)&#125;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">find</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这类注解也同时可以标记在一个类上，表示该类的所有方法都支持对应的缓存注解。</p><br/><h4 id="常用注解属性"><a href="#常用注解属性" class="headerlink" title="常用注解属性"></a><strong>常用注解属性</strong></h4><p><code>@Cacheable</code>常用的注解属性如下：</p><ul><li>  <code>cacheNames/value</code>：缓存组件的名字，即cacheManager中缓存的名称。</li><li>  <code>key</code>：缓存数据时使用的key。默认使用方法参数值，也可以使用<a href="https://docs.spring.io/spring-framework/docs/3.0.x/reference/expressions.html">SpEL</a>表达式进行编写。</li><li>  <code>keyGenerator</code>：和key二选一使用。</li><li>  <code>cacheManager</code>：指定使用的缓存管理器。</li><li>  <code>condition</code>：在方法执行开始前检查，在符合condition的情况下，进行缓存</li><li>  <code>unless</code>：在方法执行完成后检查，在符合unless的情况下，不进行缓存</li><li>  <code>sync</code>：是否使用同步模式。若使用同步模式，在多个线程同时对一个key进行load时，其他线程将被阻塞。</li></ul><p>下面是一个注解使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;UnitCache&quot;,</span><br><span class="hljs-meta">        key = &quot;#unitType + T(top.kotoumi.constants.Constants).SPLIT_STR + #unitId&quot;,</span><br><span class="hljs-meta">        condition = &quot;#unitType != &#x27;weapon&#x27;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Unit <span class="hljs-title">getUnit</span><span class="hljs-params">(String unitType, String unitId)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getUnit(unitType, unitId);<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法使用的缓存为UnitCache，并且手动指定缓存的key是<code>#unitType + Constants.SPLIT_STR + #unitId</code>的拼接结果。该缓存将在<code>#unitType != &#39;weapon&#39;</code>时生效。</p><h4 id="缓存同步模式"><a href="#缓存同步模式" class="headerlink" title="缓存同步模式"></a><strong>缓存同步模式</strong></h4><p><code>@Cacheable</code>注解支持配置同步模式。在不同的Caffeine配置下，对是否开启同步模式进行观察。</p><table><thead><tr><th align="left">Caffeine缓存类型</th><th align="left">是否开启同步</th><th align="left">多线程读取不存在/已驱逐的key</th><th align="left">多线程读取待刷新的key</th></tr></thead><tbody><tr><td align="left">Cache</td><td align="left">否</td><td align="left">各自独立执行被注解方法</td><td align="left">-</td></tr><tr><td align="left">Cache</td><td align="left">是</td><td align="left">线程1执行被注解方法，线程2被阻塞，直至缓存更新完成</td><td align="left">-</td></tr><tr><td align="left">LoadingCache</td><td align="left">否</td><td align="left">线程1执行<code>load()</code>，线程2被阻塞，直至缓存更新完成</td><td align="left">线程1使用老值立即返回，并异步更新缓存值；线程2立即返回，不进行更新。</td></tr><tr><td align="left">LoadingCache</td><td align="left">是</td><td align="left">线程1执行被注解方法，线程2被阻塞，直至缓存更新完成</td><td align="left">线程1使用老值立即返回，并异步更新缓存值；线程2立即返回，不进行更新。</td></tr></tbody></table><p>从上面的总结可以看到，sync开启或关闭，在Cache和LoadingCache中的表现是不一致的：</p><ul><li>  Cache中，sync表示是否需要所有线程同步等待</li><li>  LoadingCache中，sync表示在读取不存在/已驱逐的key时，是否执行被注解方法</li></ul><p>事实上，Cache AOP的读取流程中并没有进行加锁处理，这个参数的实际表现形式是由缓存实现方决定的。在使用Caffeine Cache时，可以根据上表，快速找到合适的组合方式。</p><br/>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022 年总结</title>
    <link href="/2022/12/15/2022total/"/>
    <url>/2022/12/15/2022total/</url>
    
    <content type="html"><![CDATA[<h2 id="2022-年总结"><a href="#2022-年总结" class="headerlink" title="2022 年总结"></a>2022 年总结</h2><p>真是时光如梭，一眨眼 22 年就要过去了。回头看看 21 年的立下 22 年展望的 flag，属于是惨不忍睹了。</p><blockquote><ul><li>减肥，身体健康捏</li><li>投资正收益</li><li>养一只猫咪</li><li>keep learn</li></ul></blockquote><ul><li>减肥（完成）</li></ul><p>过完年来到上海上了半个月班，就遇到了上海爆发疫情，然后就喜提三个月封禁。wow，我是个比较宅的人，没啥零食吃倒是瘦了 20斤。不过解封后学习做饭，自己吃自己做的饭体重又回到了 120，不过比去年比还是轻了 10 斤。<del>中间还曾经拥有过 8 块腹肌</del></p><ul><li>投资正收益（失败）</li></ul><p>果不其然，作为一个投资新手，不交点学费是不行的。美股中房，万年能赚钱的投资逻辑都变了，涩涩发抖，我不玩了把钱给我.jpg</p><ul><li>养一只猫咪（失败）</li></ul><p>没有😺吸我要死了，年中搬了一次家，房东要求不养宠物，呜呜呜，我的养猫计划再一次失败，风暴哭泣。</p><ul><li>keep learn（50%）</li></ul><p>学习确实也一直在学习，不过没有达到自己想要的效果吧。只能说是再接再厉了。</p><h3 id="闲谈"><a href="#闲谈" class="headerlink" title="闲谈"></a>闲谈</h3><ul><li>年中领导提名，我的职级提了一级。年底公司进行了两轮裁员，我们组后端开发倒是没影响（<del>因为前半年就离职了 5 个人</del>），前端走了 2 个人。看来大环境确实不好，难顶。</li><li>三季度的时候，大家对疫情都是闻风丧胆，但是到目前位置（12月），突然就完全放开了，想去哪里去哪里，除了出行还是需要带口罩。这几天办公室不少同事就中招了，希望能平平稳稳过完年。</li></ul><h2 id="2023-年展望"><a href="#2023-年展望" class="headerlink" title="2023 年展望"></a>2023 年展望</h2><p>又到了喜闻乐见的立 flag 环节了，让我们看看大聪明明年要立下什么目标</p><ul><li>养一只猫咪！ （明年必养👿）</li><li>减肥（虽然今年瘦了，但是我的 8 块腹肌没了，我要找它回来）</li><li>23 年投资正收益（这次得调整一下，不能算历史收益了，不然感觉后面几年这目标都无法达成）</li><li>1 km 跑成绩 4 分 10 秒内（毕业就没咋跑步了，不给自己太高门槛）</li><li>换一块新显卡（没错，如此简单的目标，谁让我用一块 rx580 4g 矿卡用了三年）</li><li>keep learn （之前前端学的都忘完了，准备重新捡起来）</li><li>会做的家常菜 3 个以上</li></ul><p>洋洋洒洒写完了，明年必将 100% 完成这些目标😡</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>感悟</tag>
      
      <tag>书籍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈代码评审</title>
    <link href="/2022/09/28/code-review-1/"/>
    <url>/2022/09/28/code-review-1/</url>
    
    <content type="html"><![CDATA[<p><a name="CuBQV"></a></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近轮到我技术分享了，把分享内容发到博客吧</p><p>对于开发同学而言，如何保证高质量代码，代码评审和重构是不可缺少的一环，通过代码评审，可以尽早的发现项目中存在的问题，也可以帮助同事之间的沟通与交流。<br><a name="uWBcC"></a></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>代码评审的好处</li><li>code review 流程</li><li>code review 的内容</li><li>如何高效 code review</li><li>总结<br><a name="bcd32cba"></a></li></ul><h2 id="代码评审的好处"><a href="#代码评审的好处" class="headerlink" title="代码评审的好处"></a>代码评审的好处</h2><ul><li>提高代码质量</li></ul><blockquote><ol><li>对于同一段业务代码，由于看待问题的角度不同，评审者可能会比开发者更容易发现其中的问题，或是找到更有效的解决方案，共同维护团队的代码质量。</li><li>提高代码质量和可维护性, 可读性等。</li><li>查漏补缺, 发现一些潜在的问题点等。</li><li>最佳实践, 能够更好更快的完成任务的方法。</li><li>知识分享, Review 他人代码时, 其实也是一个学习的过程, 自己也会反思&amp;总结。</li></ol></blockquote><ul><li>开发者收获</li></ul><blockquote><ol><li>对需求的理解得到加深。</li><li>表达能力得到加强。</li><li>逻辑能力得到训练。</li><li>心理承受能力得到提高。</li></ol></blockquote><ul><li>评审者收获</li></ul><blockquote><p>通过有效的代码 Review，Owner 和 Reviewer 都将获得成长，在 Review 过程中参与人就具体的问题展开深入的讨论，无论是怎么写出整洁的代码、怎么更好地更全面地思考问题、怎么最佳地解决问题，参与人都可以互相取长补短，互相提高。通过具体代码实现进行的讨论往往是最深入和有效的，代码 Review 是开发者提高代码能力最重要的途径之一。<br><img src="https://s3.bmp.ovh/imgs/2022/09/28/a0b50d08ca6edf6a.png" alt="image-20220928153159476"></p></blockquote><ul><li>快速了解业务</li></ul><blockquote><p>理想状态下，团队中的每个人都需要对整个项目的各个部分都很熟悉，当然，在项目很大时这是不现实的。通过代码审查至少可以让每个人了解更多的业务模块，同时也能达到人员互备的目的。<br>通过相互 CR，评审者也相当于参与了这次开发，相当于一种人力“备份”，当你休假或正在忙别的需求的时候，这时“备份”或许就能帮上忙了。</p></blockquote><p><a name="J2OwD"></a></p><h2 id="code-review-流程说明"><a href="#code-review-流程说明" class="headerlink" title="code review 流程说明"></a>code review 流程说明</h2><p><img src="https://s3.bmp.ovh/imgs/2022/09/28/4dc72d3479b6ee5d.png" alt="image-20220928153137793"><br><a name="Rntze"></a></p><h2 id="code-review-内容"><a href="#code-review-内容" class="headerlink" title="code review 内容"></a>code review 内容</h2><p><a name="Gw5Ty"></a></p><h3 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h3><p>这个是最基本的要求，如果连逻辑都无法实现功能，那也没有继续看的必要了。 首先我们看下需求文档，自己上手去系统熟悉下业务，然后看下设计文档，设计文档里头就会有数据库设计，接口罗列等，然后再开始看代码逻辑是不是对的上。<br><a name="MI7CN"></a></p><h3 id="技术上"><a href="#技术上" class="headerlink" title="技术上"></a>技术上</h3><p><a name="vUWl6"></a></p><h4 id="1-可读性"><a href="#1-可读性" class="headerlink" title="1. 可读性"></a>1. 可读性</h4><ul><li><strong>代码格式</strong></li></ul><p>整体代码风格保持一致，可以让阅读者比较好的阅读环境</p><ul><li><strong>字段、变量、参数、方法、类的命名是否真实反映它们所代表的事物。</strong></li><li><strong>注释</strong></li></ul><p>恰到好处的注释，能够帮助评审者更好地理解函数体和类。</p><ul><li><strong>方法逻辑简洁</strong></li></ul><p>方法要尽可能的简洁明了，这样后期维护可以通过方法名，或者方法上的备注，一眼看出这个方法是干嘛用的</p><ul><li><strong>提交记录清晰</strong>。<br><a name="Dahg5"></a></li></ul><h4 id="2-设计上"><a href="#2-设计上" class="headerlink" title="2. 设计上"></a>2. 设计上</h4><ul><li>代码的位置是否正确？比如涉及订单的新代码是否在订单服务相关的位置？</li><li>新代码是否重用了现存的代码？新代码是否可以被现有代码重用？新代码是否有重复代码？如果是的话，是否应该重构成一个更可被重用的模式，还是当前还可以接受？</li><li><strong>表</strong></li></ul><p>数据表是很源头的地方，如果设计不好，后面会经常变动。表设计满足第三原则，尽量剥离各个表的依赖，然后主表跟附属表隔开。</p><ul><li><strong>接口设计</strong></li></ul><p>是否根据业务需求考虑接口设计保留一定扩展性<br><a name="FaB3l"></a></p><h4 id="3-性能相关"><a href="#3-性能相关" class="headerlink" title="3. 性能相关"></a>3. 性能相关</h4><ul><li>这段代码是否有硬性性能需求，是否满足？</li><li>调用数据库</li></ul><p>如在循环中逐个调用数据库，一种情况就是加载ID列表之后，再在数据库中逐个查询ID对应的每条数据。</p><ul><li>不必要的网络调用</li></ul><p>就像数据库一样，远程服务有时也会被过度使用，原来只要一个远程调用就可实现的，或者可以使用批量或缓存防止昂贵网络调用的，却使用多个远程调用来实现。</p><ul><li>是否存在内存泄露 &amp; 无限增长问题？</li></ul><p>Java 中一些常见的原因会是：可变的静态字段，使用 ThreadLocal 变量和使用类加载器。 如果你看见新的变量不断被加到list或map中，你就要问下，这个list或map什么时候失效或清除无用数据。</p><ul><li>资源池是否配置正确？</li></ul><p>针对一个环境的最佳配置取决于很多因素，所以作为审查者你很难马上知道像数据库连接池大小是否正确等这些问题。但是有一些是你一眼就可以看出来的，像资源池是否太小（比如大小设置为1）或太大（如数百万线程）。</p><ul><li>代码是否使用了正确的适合多线程的数据结构</li><li>代码是否正确使用锁？作为审查者你应该检查被审代码是否允许多个线程修改变量导致程序崩溃。代码可能需要同步、锁、原子变量来对代码块进行控制。<br><a name="xatwM"></a></li></ul><h4 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h4><h4 id="提交代码尽量保证为单一业务，代码不过多"><a href="#提交代码尽量保证为单一业务，代码不过多" class="headerlink" title="提交代码尽量保证为单一业务，代码不过多"></a>提交代码尽量保证为单一业务，代码不过多</h4><p><a name="J95hY"></a></p><h5 id="代码级优化"><a href="#代码级优化" class="headerlink" title="代码级优化"></a>代码级优化</h5><p>对大部分并不是要构建低延时应用的机构来说，代码级优化往往是过早优化，所以首先要知道代码级优化是否必要。</p><ul><li>代码是否在不需要的地方使用同步或锁操作？如果代码始终运行在单线程中，锁往往是不必要的。</li><li>代码是否可以使用原子变量替代锁或同步操作？</li><li>代码是否使用了不必要的线程安全的数据结构？比如是否可以使用ArrayList替代Vector？</li><li>代码是否在通用的操作中使用了低性能的数据结构？如在经常需要查找某个特定元素的地方使用链表。</li><li>代码是否可以使用懒加载并从中获得性能提升？</li><li>条件判断语句或其他逻辑是否可以将最高效的求值语句放在前面来使其他语句短路？</li><li>代码是否存在许多字符串格式化？是否有方法可以使之更高效？<br><a name="ATone"></a></li></ul><h5 id="引用第三方类库"><a href="#引用第三方类库" class="headerlink" title="引用第三方类库"></a>引用第三方类库</h5><p>第三方类库是侵蚀系统安全并引起漏洞的一个途径。当审查代码时至少你要检查是否引入了新的依赖。<br><a name="HUQoB"></a></p><h5 id="代码的运行是否应该被日志记录或监控？是否正确地使用？"><a href="#代码的运行是否应该被日志记录或监控？是否正确地使用？" class="headerlink" title="代码的运行是否应该被日志记录或监控？是否正确地使用？"></a>代码的运行是否应该被日志记录或监控？是否正确地使用？</h5><p>日志和监控需求因各个项目而不同，一般会关注这些：</p><ul><li>代码是否改变了数据（如增删改操作）？是否应该记录由谁何时改变了什么？</li><li>代码是否涉及关键性能的部分？是否应该在性能监控系统中记录开始时间和结束时间？<br><a name="eIS0q"></a></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="如何高效-code-review"><a href="#如何高效-code-review" class="headerlink" title="如何高效 code review"></a>如何高效 code review</h3><ul><li>明确 code review 中事项的优先级</li></ul><p>从上面也能看出来 code review 要关心的事项还是很多的，所以安排事项优先级可以帮助处理主要问题。</p><ul><li>尽可能及时的进行 code review</li></ul><p>当你收到别人的 code review 邀请时，尽量第一时间就开始。因为这时我们的记忆是最清晰的，并且通常会        对你的及时反馈心怀感激，这种正面情绪对于 code review 是非常有帮助的。</p><ul><li>可以在 ide 开发环境中去 reivew</li></ul><p>一般我们 code review 是在 gitlab 中自己用眼睛去看，更好的方式是用 IDE 各种自动提示功能，各种强大的     IDE 完全可以成为我们的一大助力。</p><ul><li>不要吝啬你的赞扬</li></ul><p>每个人的内心深处都是期待被别人称赞的，因此在 code review 开始的时候不要老是揪着变量命名、代码重    复之类的问题。code review 中发现好代码，可以给作者一些赞美，这样他们也就会乐于接受你对于代码风格等方面的建议了——它能培养出强大而积极进取的团队  : )</p><ul><li>把程序跑起来</li></ul><p>把程序运行起来，亲自试一试，或许你会有一些和他们测试时不同的操作，发现一些他们遗漏的问题。</p><ul><li>明确 Coding 规则标准</li></ul><p>没错，和公司 kpi 一样，只有量化的指标，才能高效的执行。比如一个方法多少行算过长？如果总是参考上下文去判断，后面所有人就不会考虑这个问题了，因为太难判断，强制规定为一个方法最多不超过 80 行，code review 该事项则会事半功倍。</p><ul><li>善用各种自动化工具</li></ul><p>可以搭建好各种完善的自动化流程，如 CI/CD，代码质量测试工具：SonarQube等，把一些工作交给机器总是比人更高效的。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>代码审查是针对代码，不是针对人。代码审查是一种学习，是表扬，是获得反馈，是一种十分社交性的活动。代码审查应该是有趣的，不要让它变的无聊。</p><ul><li>适当的激励机制更好的激发团队主动性。</li><li>按照经验，code review 启动前期建议采用强制要求，否则很难有效开展起来。坚持一段时间待习惯养成后再考虑放开。</li><li>code review 的方式有多种方式：强制&amp;非强制、线上交流&amp;线下会议、小片段&amp;大模块、事前&amp;事后、高频率&amp;低频率，建议根据团队水平因地制宜。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技术</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22年中阅读书籍总结</title>
    <link href="/2022/08/23/book-2202-08/"/>
    <url>/2022/08/23/book-2202-08/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>上一次总结读书是居然是去年了，<del>我有罪.jpg</del>，一定都是疫情的问题（肯定脸）</p><h3 id="技术相关"><a href="#技术相关" class="headerlink" title="技术相关"></a>技术相关</h3><ul><li>《高性能 MySql》 </li></ul><blockquote><p>经典中的经典，书很厚，内容非常全面，基本涵盖了所有 MySql 使用中需要了解的基础和进阶知识，认真看完基本就没有知识死角了书的语言风格和内容编写都非常好，没有废话，全书无任何尿点。</p></blockquote><ul><li>《数据密集型应用系统设计》 </li></ul><blockquote><p>推荐，首先要说明的是，这本书没有介绍什么新技术，很多内容都是我们所熟悉的。也没有具体讲解某一种技术的细节，不能期望读完本书后成为某种专家。同样的书很厚，讲了很多，算是大杂烩吧。看看可以开阔视野，也算是一本不错的书</p></blockquote><ul><li>《凤凰架构》  </li></ul><blockquote><p>强力推荐，因为这本书不要钱！作者是周志明，看着眼熟就对了，《[深入理解Java虚拟机 : JVM高级特性与最佳实践]》，这本书也是他写的。《凤凰架构》这本书和上面那本比较像，不过作者书里有一些代码实战。</p></blockquote><ul><li>《软技能：代码之外的生存指南》</li></ul><blockquote><p>个人感觉一般，书的内容基本可以用四个字形容——人情世故，我愿称之为程序员的鸡汤，里面也就面试那个章节内容好像还行，当我了解到作者是靠房地产实现财富自由以后就不是很想看了😅。</p></blockquote><h2 id="生活相关"><a href="#生活相关" class="headerlink" title="生活相关"></a>生活相关</h2><ul><li>《理想国》</li></ul><blockquote><p>没事看罗翔老师，被他推荐阅读这本书，哈哈哈。哲学相关的，看完以后一脸懵逼，就记得哲人王，洞喻这两个概念，不过感悟也有一些，什么是正义，辩证法，教育的意义，这些问题确实远远比想象中的复杂很多。</p></blockquote><ul><li>《山》 刘慈欣</li></ul><blockquote><p>确实如大刘所说，山是无处不在的，曾几何时年少轻狂的时候，在那个生活了许多年的小村子里面，看着连绵的群山，总想看看山的那边到底是什么，对于未知世界的探索是人类整体前进的根本动力。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>书籍</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一揽子工具推荐之 idea 插件与快捷键</title>
    <link href="/2022/07/07/tool-04/"/>
    <url>/2022/07/07/tool-04/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>作为每天都要使用的工具 Idea ，当然也有很多提高我们工作效率的插件，下面推荐一些我个人喜爱的插件</p><h2 id="arthas-idea"><a href="#arthas-idea" class="headerlink" title="arthas idea"></a>arthas idea</h2><img src="https://s3.bmp.ovh/imgs/2022/07/07/254e82dea6537aa8.png" alt="image-20220707154824535" style="zoom:50%;" /><blockquote><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。</p></blockquote><p>arthas 的命令也是很多，学习成本也是有一些的，配合这些插件，直接生成命令，帮助我们排查问题，可以事半功倍。</p><h2 id="RestfulTool"><a href="#RestfulTool" class="headerlink" title="RestfulTool"></a>RestfulTool</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/07/e461e29008dfd207.png" alt="image-20220707155134040"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/07/9bafd856ed2f2041.gif" alt="动画1"></p><p>虽然 idea 自带了 symbol 功能也可以查询接口，但是查询起来还是没那么方便，用 RestfulTool  查起来就方便很多啦。</p><h2 id="translation"><a href="#translation" class="headerlink" title="translation"></a>translation</h2><p>这个应该都知道了，英语苦手必备，翻译变量名称的时候使用一下，也可以避免很多笑话。</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/07/9efafb925fe0d2ca.gif" alt="动画2"></p><h2 id="mybatisLogFormat"><a href="#mybatisLogFormat" class="headerlink" title="mybatisLogFormat"></a>mybatisLogFormat</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/aa0902187ed4efb35544a1325e745128.png" alt="image"></p><p>平时经常要看 sql 输出到底是什么，用它很快就可以得到最终执行的 sql 语句，很方便我们去排查或者调试。</p><h2 id="idea-快捷键"><a href="#idea-快捷键" class="headerlink" title="idea 快捷键"></a>idea 快捷键</h2><p>其实 idea 已经提供了很多好用的功能，使用快捷键的话也会更方便。下面介绍一些可能比较冷门但又很好用的，</p><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + P</td><td>方法参数提示显示</td></tr><tr><td>Alt + 左右方向键</td><td>按左方向切换当前已打开的文件视图</td></tr><tr><td>Ctrl + Shift + Backspace</td><td>退回到上次修改的地方</td></tr><tr><td>F2</td><td>跳转到下一个高亮错误 或 警告位置</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工具推荐系列到此应该算是告一段落了，后面有新的好用的工具，到时候再更新。♥️</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一揽子工具推荐之 Chrome 插件</title>
    <link href="/2022/07/06/tool-03/"/>
    <url>/2022/07/06/tool-03/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>作为一个 Java Web 开发，那是常年和浏览器打交道，下面推荐一些好用的 chrome 插件</p><h2 id="Adblock-Plus"><a href="#Adblock-Plus" class="headerlink" title="Adblock Plus"></a>Adblock Plus</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/06/afc21343eae9f300.png" alt="image-20220706131931197"></p><p>一款屏蔽网页广告的插件，从用户量就能看出，一致好评！</p><h2 id="Language-Reactor"><a href="#Language-Reactor" class="headerlink" title="Language Reactor"></a>Language Reactor</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/06/f9f3f66db1bbfaea.png" alt="image-20220706132520890"></p><p>一款可以实时翻译 youtube，网飞视频的插件，还有双语对比，对于学习英语的人或者喜欢看 youtube 视频的人挺有帮助的。</p><h2 id="LastPass-Free-Password-Manager"><a href="#LastPass-Free-Password-Manager" class="headerlink" title="LastPass: Free Password Manager"></a>LastPass: Free Password Manager</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/06/e7293811d5e58742.png" alt="image-20220706132727708"></p><p>平时经常注册各种各样账号，或者测试用户，密码账号多的都记不住，用这个插件就不用自己记密码啦，免费版的基本也够用了。</p><h2 id="Proxy-SwitchyOmega"><a href="#Proxy-SwitchyOmega" class="headerlink" title="Proxy SwitchyOmega"></a>Proxy SwitchyOmega</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/06/4d60412501470508.png" alt="image-20220706133027320"></p><p>科学上网必备</p><h2 id="Tampermonkey"><a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a>Tampermonkey</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/06/d99b598ec60256c5.png" alt="image-20220706133202163"></p><p>这是一款支持自定义脚本的插件，也可以从别的脚本平台用别人写好的脚本，这个应该大部分都用过，哈哈。</p><h2 id="Vimium"><a href="#Vimium" class="headerlink" title="Vimium"></a>Vimium</h2><p>可以用 vim 方式操作浏览器，个人很喜欢</p><h2 id="书签侧边栏"><a href="#书签侧边栏" class="headerlink" title="书签侧边栏"></a>书签侧边栏</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/06/b7e0d9a6da8ab27e.png" alt="image-20220706133526204"></p><p>支持书签查找，书签太多的时候经常找不到某一个书签，或者只记得书签一部分名字去查找，很方便。</p><h2 id="沙拉查词"><a href="#沙拉查词" class="headerlink" title="沙拉查词"></a>沙拉查词</h2><p>这个就不多介绍了，英语苦手必备</p><h2 id="自选基金助手-实时查看基金涨跌幅"><a href="#自选基金助手-实时查看基金涨跌幅" class="headerlink" title="自选基金助手 - 实时查看基金涨跌幅"></a>自选基金助手 - 实时查看基金涨跌幅</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/06/d27c9e0b3aa2b19d.png" alt="image-20220706133736932"></p><p>身为一个老韭菜，当然没事看看基金和大盘咋样了，省的还要用手机看。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一揽子工具推荐之命令行工具与 windows 工具</title>
    <link href="/2022/07/05/tool-02/"/>
    <url>/2022/07/05/tool-02/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>弄好了 GitBash 和 Windows terminal，当然不能少了一些命令行工具啦，附带的也会推荐一些配合这些工具很好用的 utools</p><h2 id="scoop"><a href="#scoop" class="headerlink" title="scoop"></a>scoop</h2><p>使用命令行当然少不了包管理工具了，最推荐的还是 scoop 了。减少了安装软件杂七杂八的步骤，还能找到很多使用的命令行工具</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>根据 <a href="https://github.com/ScoopInstaller/Scoop#installation">文档</a> 来，打开 powershell 输入下面的命令即可安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">iwr -useb get.scoop.sh | iex<br></code></pre></td></tr></table></figure><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>一看就懂，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text">alias      Manage scoop aliases<br>bucket     Manage Scoop buckets<br>cache      Show or clear the download cache<br>checkup    Check for potential problems<br>cleanup    Cleanup apps by removing old versions<br>config     Get or set configuration values<br>create     Create a custom app manifest<br>depends    List dependencies for an app<br>export     Exports (an importable) list of installed apps<br>help       Show help for a command<br>home       Opens the app homepage<br>install    Install apps<br>list       List installed apps<br>reset      Reset an app to resolve conflicts<br>search     Search available apps<br>status     Show status and check for new app versions<br>uninstall  Uninstall an app<br>update     Update apps, or Scoop itself<br>which      Locate a program path<br></code></pre></td></tr></table></figure><h3 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h3><p>jq，是我经常用的，比如拉下来的日志里有 json 数据，直接 <code>grep xxx | jq</code> 可以很方便的可视化 json 数据，不必复制粘贴这些步骤。</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/05/c33cd557293a09b2.png" alt="image-20220705134545142"></p><p>比如这样的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">error<br>&#123;&quot;name&quot;:&quot;test&quot;,&quot;age&quot;:13&#125;<br></code></pre></td></tr></table></figure><p>配合 tail ，less 等命令，可以很灵活的格式化 json 数据，可以说是相当方便了。</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/05/499c4b1a9720999f.png" alt="image-20220705135053933"></p><h2 id="utools"><a href="#utools" class="headerlink" title="utools"></a>utools</h2><p>第二个我想推荐的工具就是我用了两年快捷工具，快速启动软件，还是很方便的，里面还集成了许多好用的插件</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><a href="https://u.tools/docs/guide/about-uTools.html#utools-%E6%98%AF%E4%BB%80%E4%B9%88">utools 是什么</a> </p><p><code>alt + 空格</code> 可以快速呼出想要使用的软件，如图所示，还是很方便的</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/05/7157c8ad6f6a0094.gif" alt="动画"></p><h3 id="utools-小插件推荐"><a href="#utools-小插件推荐" class="headerlink" title="utools 小插件推荐"></a>utools 小插件推荐</h3><p>utools 提供了许多小插件，下面推荐一些我经常用，感觉很不错的插件。</p><img src="https://s3.bmp.ovh/imgs/2022/07/05/99bc6f30d2483733.png" alt="image-20220705143600219" style="zoom:50%;" /><ul><li>json 编辑器</li></ul><blockquote><p>用了就爱不释手，还可以输入一些简单的 js 对 json 数据进行操作</p></blockquote><ul><li>linux 命令文档</li></ul><blockquote><p>可以说是懒人必备，很多 linux 命令参数多，一时半会也想不起来，根据这个查示例也很多，方便！</p></blockquote><ul><li>沙拉查词</li></ul><blockquote><p>英语苦手必备</p></blockquote><h2 id="ScreenToGif"><a href="#ScreenToGif" class="headerlink" title="ScreenToGif"></a>ScreenToGif</h2><p>写文档经常需要用到录制一些动图，所以就推荐这个，不过用的次数不多（<del>就是懒狗不咋写博客了</del>）。</p><p>免费软件，不过缺点可能就是 only windows 😂，上面的 gif 图就是用它录的，</p><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><a href="https://www.screentogif.com/">官网</a></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/05/470b05e0d23e788c.png" alt="image-20220705144738913"></p><p>还有中文还免费，<del>还要啥自行车</del>。</p><h2 id="PowerToys"><a href="#PowerToys" class="headerlink" title="PowerToys"></a>PowerToys</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>微软推出的小工具集，有些功能还挺好用</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/05/606bc07619320f04.png" alt="image-20220705144959390"></p><h3 id="推荐功能"><a href="#推荐功能" class="headerlink" title="推荐功能"></a>推荐功能</h3><p>推荐一些里面我常用的功能</p><ul><li>键盘管理器</li></ul><blockquote><p>可以单独设置键盘映射与快捷键，偶尔会用上</p></blockquote><ul><li> FancyZones</li></ul><blockquote><p>屏幕布局调整，可以很方便调整各个软件在屏幕的布局，经常用，赞一个！</p></blockquote><ul><li>powerToys run</li></ul><blockquote><p>不是很喜欢 utools 的，可以用这个，和 utools 的快捷启动基本一样</p></blockquote><h2 id="Snipaste"><a href="#Snipaste" class="headerlink" title="Snipaste"></a>Snipaste</h2><p>不会还有人在用 QQ 截图吧，（<del>别说，QQ 截图也算是很好用的</del>）</p><p>经常有截图的功能需求，一定要用一下 snipaste，本文所有图片也都是 snipaste 截图生成，按 F1 即可截图，非常方便。</p><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p><a href="https://docs.snipaste.com/zh-cn">官网</a></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/05/31bb55b0c518d0b8.png" alt="image-20220705145628386"></p><p>F1 截图，F3 暂留屏幕，对于经常需要对比数据文件的人，这个功能基本是每天都用。</p><h2 id="everthing"><a href="#everthing" class="headerlink" title="everthing"></a>everthing</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>如果你经常忘记自己把文件扔在哪个角落里找不到了，那么 everthing 一定适合你，</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/05/6363816313bbd9d0.png" alt="image-20220705150050622"></p><p>支持模糊搜索，文件类型检索，赞！</p><h2 id="ditto"><a href="#ditto" class="headerlink" title="ditto"></a>ditto</h2><p>这应该是我日常使用频率最高的软件了，<del>毕竟是 Ctrl + C，V 工程师</del></p><p>没错，这是一个  Clipboard Manager 工具，快捷键 ``+ ctrl` 调用出历史剪切板，很方便的愉快 ctrl c v，</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/05/65089f06740e4326.png" alt="image-20220705150456205"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工欲善其事，必先利其器。</p><p>提高自己工作效率，美滋滋，哈哈哈哈</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一揽子工具推荐之 Terminal</title>
    <link href="/2022/07/04/tool-01/"/>
    <url>/2022/07/04/tool-01/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>迫于公司电脑都是 windows，又想用一些 linux 下好用的命令和工具，比如 zsh，一开始我用的 gitBash 提供的命令界面，就是丑的离谱，所以探索美化和好用的功能。</p><p>折腾了一下找到  <strong>Windows Terminal + git-bash + zsh + oh-my-zsh</strong> 这个方案，属于是用了就不用再折腾方案，哈哈哈哈</p><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><h3 id="安装-git-Bash-for-windows"><a href="#安装-git-Bash-for-windows" class="headerlink" title="安装 git Bash for windows"></a>安装 git Bash for windows</h3><p><a href="https://git-scm.com/download/win">官方下载链接</a>，安装完成后有个 git bash 程序。</p><p>记得留意一下 Git 的安装目录，下面会用到。</p><h3 id="安装-zsh"><a href="#安装-zsh" class="headerlink" title="安装 zsh"></a>安装 zsh</h3><p><a href="https://packages.msys2.org/package/zsh?repo=msys&variant=x86_64">官方下载链接</a>，下载文件直接解压到 Git 的安装目录下，与之前的文件进行合并，可以理解为把 zsh 当作 git bash 的一个补充安装包。</p><p><img src="https://files.catbox.moe/o73qcl.png" alt="image-20220704175700362"></p><p>，此时把 git Bash 调用出来，敲一个 zsh，</p><p><img src="https://files.catbox.moe/oft9nn.png" alt="image-20220704175821533"></p><p>熟悉的 zsh 就出来了，</p><h3 id="安装-Oh-My-Zsh"><a href="#安装-Oh-My-Zsh" class="headerlink" title="安装 Oh My Zsh"></a>安装 Oh My Zsh</h3><p>有了 zsh ，当然要安装 oh my zsh，在 zsh 里执行（curl）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span><br><span class="hljs-comment"># 或者 </span><br><span class="hljs-comment"># sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></code></pre></td></tr></table></figure><p>oh my zsh 相关的文件存放在 <code>~/.oh-my-zsh</code> 目录下。</p><p>而 <code>~</code> 的目录为 <code>C:\Users\&lt;your username&gt;</code>.</p><p><img src="https://files.catbox.moe/5nam74.png" alt="image-20220704180030192"></p><h3 id="Oh-My-Zsh-插件-amp-配置"><a href="#Oh-My-Zsh-插件-amp-配置" class="headerlink" title="Oh My Zsh 插件 &amp; 配置"></a>Oh My Zsh 插件 &amp; 配置</h3><p>参考 <a href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md#oh-my-zsh">官方安装说明</a></p><ul><li><h4 id="zsh-autosuggestions-自动补全"><a href="#zsh-autosuggestions-自动补全" class="headerlink" title="zsh-autosuggestions 自动补全"></a><strong>zsh-autosuggestions</strong> 自动补全</h4></li><li><h4 id="zsh-syntax-highlighting-语法高亮"><a href="#zsh-syntax-highlighting-语法高亮" class="headerlink" title="zsh-syntax-highlighting 语法高亮"></a><strong>zsh-syntax-highlighting</strong> 语法高亮</h4></li></ul><h3 id="配置-zsh-为-bash-默认终端"><a href="#配置-zsh-为-bash-默认终端" class="headerlink" title="配置 zsh 为 bash 默认终端"></a>配置 zsh 为 bash 默认终端</h3><p>编辑 <code>~/.bashrc</code>文件，加入下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Launch Zsh</span><br><span class="hljs-keyword">if</span> [ -t 1 ]; <span class="hljs-keyword">then</span><br><span class="hljs-built_in">exec</span> zsh<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h3 id="配置-windows-terminal-使用-git-Bash"><a href="#配置-windows-terminal-使用-git-Bash" class="headerlink" title="配置 windows terminal 使用 git Bash"></a>配置 windows terminal 使用 git Bash</h3><p>在 Microsoft Store 里安装 Windows Terminal ，其他可以参考 <a href="https://blog.csdn.net/chenzz444/article/details/118658621">https://blog.csdn.net/chenzz444/article/details/118658621</a> 的博客</p><h3 id="常用-git-bash-快捷键"><a href="#常用-git-bash-快捷键" class="headerlink" title="常用 git bash 快捷键"></a>常用 git bash 快捷键</h3><h4 id="常用的快捷键"><a href="#常用的快捷键" class="headerlink" title="常用的快捷键"></a>常用的快捷键</h4><table><thead><tr><th align="left">按键</th><th align="left">效果</th></tr></thead><tbody><tr><td align="left">Alt + Enter</td><td align="left">全屏</td></tr><tr><td align="left">关闭窗口</td><td align="left">Ctrl + D（需当前行没有字符才可用）</td></tr><tr><td align="left">清屏</td><td align="left">Ctrl + L</td></tr><tr><td align="left">打开终端</td><td align="left">右键快捷方式，在属性中自行设置</td></tr><tr><td align="left">复制粘贴</td><td align="left">Ctrl + Shift + C/V（v2.20.0 版本后才支持）</td></tr></tbody></table><blockquote><p>其他 Bash 快捷键也可以用，比如 ctrl e/a 光标到行首行尾，等等等</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://files.catbox.moe/7845q9.png" alt="image-20220704181246893"></p><p>用起来还是想当舒服的，哈哈😂</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>年中总结</title>
    <link href="/2022/06/11/ret-06/"/>
    <url>/2022/06/11/ret-06/</url>
    
    <content type="html"><![CDATA[<p>上一次更新博客是在三月初，没想到一晃就是三个月。</p><h2 id="疫情"><a href="#疫情" class="headerlink" title="疫情"></a>疫情</h2><p>刚过完年回公司上班，都已经想好五一去哪里玩了，没想到遇到上海疫情大封闭，三月十五号关到六月一号解封，感觉整个人都不好了，这大抵就是摸鱼的理由吧。中间封闭的时候天天比较烦躁，快递啥的也不通，于是在学习新知识方面确实也停滞了。</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>减肥</li></ul><p>古人云：塞翁失马焉知非福，被关两个月也收获了很多，比如开始是封闭的时候，没有存够食物，加上自己也想减肥，封闭前 130 斤的体重，解封变成了 110 斤，原来肚子只有一块，现在可以隐约看到 8 块腹肌了（<del>解封一个星期胖了两斤了，呜呜呜，8 块腹肌不要走</del>）</p><ul><li>做饭</li></ul><p>小区封闭期间也点不了外卖，只能自己做饭吃，我自己见证了自己，从一个厨房小白变成了能饭给自己吃了（<del>就是味道差了点</del>），刚开始连生抽和老抽的区别都不知道，也算是习得技能一件，厨艺 + 1</p><ul><li>健身</li></ul><p>因为天天宅家里也出不去，当时想着得在家里锻炼一下，坚持了一个月，能模糊的看到 8 块腹肌，结果五月一号后就摆烂了，本来说是解封了以后要每周跑步的，我自己都信了😡</p><ul><li>戒烟</li></ul><p>从去年六月戒烟，除了过年回家和朋友团聚那几天抽了几包，到今年六月基本算是成功戒烟一年，开心😀，戒烟的秘诀就是不要买烟，没有烟自然就不抽，哈哈哈哈（同事白给的烟还是会抽一下的😂）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>​    2022 年展望</p><ul><li>减肥，身体健康捏</li><li>投资正收益</li><li>养一只猫咪</li><li>keep learn</li></ul></blockquote><p>根据去年的展望，减肥算是成功了，投资正收益好像还是有点远，大 A 的镰刀还是有点猛🤡，养一只猫可能得最近搬家才能养，目前还没实现，算是今年上半年 kpi 勉强达标吧。</p><p>下半年展望</p><ul><li>继续戒烟</li><li>保持每周运动，1 km 跑成绩进入 4分</li><li>保持 8 块腹肌（<del>感觉够呛</del>）</li><li>养一只猫咪</li><li>keep learn</li></ul><p>最后上半年疫情影响了太多人，直到今天上海快递也没恢复过来，悲伤的事已不想再回忆，希望上海早日恢复正常。🌹</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术文档的写作规范</title>
    <link href="/2022/03/03/write-guide/"/>
    <url>/2022/03/03/write-guide/</url>
    
    <content type="html"><![CDATA[<h1 id="技术文档的写作规范"><a href="#技术文档的写作规范" class="headerlink" title="技术文档的写作规范"></a>技术文档的写作规范</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p> 迫于自己文档写的一般，抽时间写一个总结，学习优秀文档编写经验</p></blockquote><h2 id="个人实战总结"><a href="#个人实战总结" class="headerlink" title="个人实战总结"></a>个人实战总结</h2><ul><li>参照标准文档编写。</li><li>编写完重读一遍，看看结构是否合理。</li><li>学会精炼语言，减少废话。</li><li>考虑阅读者是谁来决定怎么写</li><li>文档可以分为四个部分考量，术语规范；问题描述；客户需求；详尽描述。</li></ul><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>标题分为四级。</p><ul><li>一级标题：文章的标题</li><li>二级标题：文章主要部分的大标题</li><li>三级标题：二级标题下面一级的小标题</li><li>四级标题：三级标题下面某一方面的小标题</li></ul><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><h3 id="字间距"><a href="#字间距" class="headerlink" title="字间距"></a>字间距</h3><p>（1）全角中文字符与半角英文字符之间，应有一个半角空格。</p><p>（2）全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p><p>（3）半角的百分号，视同阿拉伯数字。</p><p>（4）半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p><h3 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h3><p>（1）避免使用长句。</p><p>（2）尽量使用简单句和并列句，避免使用复合句。</p><p>（3）同样一个意思，尽量使用肯定句表达，不使用否定句表达。</p><h3 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h3><p>（1）尽量不使用被动语态，改为使用主动语态。</p><p>（2）不使用非正式的语言风格。</p><p>（3）不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式。</p><p>（4）名词前不要使用过多的形容词。</p><h3 id="英文"><a href="#英文" class="headerlink" title="英文"></a>英文</h3><p>（1）外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</p><p>（2）外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</p><p>（3）表示中文时，英文省略号（<code>...</code>）应改为中文省略号（<code>⋯⋯</code>）。</p><p>（4）英文书名或电影名改用中文表达时，双引号应改为书名号。</p><p>（5）第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</p><p>（6）专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</p><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>（1）一个段落只能有一个主题，或一个中心句子。</p><p>（2）段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</p><p>（3）一个段落的长度不能超过七行，最佳段落长度小于等于四行。</p><p>（4）段落之间使用一个空行隔开。</p><p>（5）段落开头不要留出空白字符。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用第三方内容时，应注明出处。</p><h2 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h2><h3 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h3><ul><li>中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。</li><li>如果整句为英文，则该句使用英文/半角标点。</li><li>句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</li><li>应该使用平静的语气叙述，尽量避免使用感叹号<code>！</code>。</li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p>写作逻辑很重要，推荐一些书籍。</p><ul><li>《魏斯曼演讲圣经》</li><li>《金字塔结构》</li><li>《写给大家看的设计书》</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://developers.google.com/style/">Google Developer Documentation Style Guide</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2016/10/document_style_guide.html">阮一峰 中文技术文档的写作规范</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>感悟</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新年快乐</title>
    <link href="/2022/01/06/2021total/"/>
    <url>/2022/01/06/2021total/</url>
    
    <content type="html"><![CDATA[<h2 id="2021年总结"><a href="#2021年总结" class="headerlink" title="2021年总结"></a>2021年总结</h2><ul><li>果不其然，还是变胖了，当事人，后悔.jpg，就是非常的后悔.jpg</li><li>技术上的提升只能说是自己不是很满意😂，<del>后面一定好好钻研技术（确信）</del></li><li>养一只猫的心愿还是没有达成，属于是大失败事件了</li><li>啊，作为 A 股基民，第一年成功负收益，😭😭，总是要交学费的。</li></ul><h2 id="2022年展望"><a href="#2022年展望" class="headerlink" title="2022年展望"></a>2022年展望</h2><ul><li>减肥，身体健康捏</li><li>投资正收益</li><li>养一只猫咪</li><li>keep learn</li></ul><p>ps: 上海疫情搞得行程码又带星了，能不能过年回家成了个问题😭</p><p>最后，米娜桑，2022，happy new year😃</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jackJson 相关配置</title>
    <link href="/2021/11/18/jsoninfo-0/"/>
    <url>/2021/11/18/jsoninfo-0/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>好久没记录了，记录一下 JacksonJson 常用的注解配置吧</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>有时候返回对象里有 null 值或者为 “” 值的，不想返回这种字段可以在对象上用上这个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span><br></code></pre></td></tr></table></figure><h3 id="Bean-配置"><a href="#Bean-配置" class="headerlink" title="Bean 配置"></a>Bean 配置</h3><p>想整个项目统一处理的话，配置一个 Configuration 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JacksonConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Primary</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(ObjectMapper.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ObjectMapper <span class="hljs-title">jacksonObjectMapper</span><span class="hljs-params">(Jackson2ObjectMapperBuilder builder)</span> </span>&#123;<br>        ObjectMapper objectMapper = builder.createXmlMapper(<span class="hljs-keyword">false</span>).build();<br>        <span class="hljs-comment">// 通过该方法对mapper对象进行设置，所有序列化的对象都将按改规则进行系列化</span><br>        <span class="hljs-comment">// Include.Include.ALWAYS 默认</span><br>        <span class="hljs-comment">// Include.NON_DEFAULT 属性为默认值不序列化</span><br>        <span class="hljs-comment">// Include.NON_EMPTY 属性为 空（&quot;&quot;） 或者为 NULL 都不序列化，则返回的json是没有这个字段的。这样对移动端会更省流量</span><br>        <span class="hljs-comment">// Include.NON_NULL 属性为NULL 不序列化,就是为null的字段不参加序列化</span><br>        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);<br><br>         <span class="hljs-comment">//字段保留，将null值转为&quot;&quot;</span><br>        objectMapper.getSerializerProvider().setNullValueSerializer(<span class="hljs-keyword">new</span> JsonSerializer&lt;Object&gt;()<br>        &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(Object o, JsonGenerator jsonGenerator,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  SerializerProvider serializerProvider)</span></span><br><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException, JsonProcessingException</span><br><span class="hljs-function">            </span>&#123;<br>                jsonGenerator.writeString(<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> objectMapper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lambda 和 匿名内部类的区别</title>
    <link href="/2021/11/09/lambda/"/>
    <url>/2021/11/09/lambda/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Lambda表达式似乎只是为了简化匿名内部类书写，这看起来仅仅通过语法糖在编译阶段把所有的Lambda表达式替换成匿名内部类就可以了。但实时并非如此。在JVM层面，Lambda表达式和匿名内部类有着明显的差别。</p><h2 id="匿名内部类实现"><a href="#匿名内部类实现" class="headerlink" title="匿名内部类实现"></a>匿名内部类实现</h2><p>匿名内部类仍然是一个类，编译后会产生一个 class 文件</p><h2 id="Lambda表达式实现"><a href="#Lambda表达式实现" class="headerlink" title="Lambda表达式实现"></a>Lambda表达式实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainLambda</span> </span>&#123;<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/lang/Thread</span><br>       <span class="hljs-number">3</span>: dup<br>       <span class="hljs-number">4</span>: invokedynamic #<span class="hljs-number">3</span>,  <span class="hljs-number">0</span>              <span class="hljs-comment">// InvokeDynamic #0:run:()Ljava/lang/Runnable; /*使用invokedynamic指令调用*/</span><br>       <span class="hljs-number">9</span>: invokespecial #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span><br>      <span class="hljs-number">12</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/lang/Thread.start:()V</span><br>      <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lambda$main$<span class="hljs-number">0</span>();  <span class="hljs-comment">/*Lambda表达式被封装成主类的私有方法*/</span><br>    Code:<br>       <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String Lambda Thread run()</span><br>       <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>反编译代码可以看出来Lambda表达式被封装成了主类的一个私有方法，并通过<em>invokedynamic</em>指令进行调用。</p><h2 id="注意-this"><a href="#注意-this" class="headerlink" title="注意 this"></a>注意 this</h2><p>这样 lambda 里使用 this 和在类外面使用是一致的</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>国庆快乐</title>
    <link href="/2021/10/11/2021-10-11-think/"/>
    <url>/2021/10/11/2021-10-11-think/</url>
    
    <content type="html"><![CDATA[<h2 id="国庆快乐"><a href="#国庆快乐" class="headerlink" title="国庆快乐"></a>国庆快乐</h2><blockquote><p>哈哈哈哈，😊，国庆过完才想起来祝福一下，果然假期都是短暂的，这周要连上七天班，😥<br>博客半个月也没写了，属于是狠狠的给自己放了个假了。</p><p>啊啊啊啊，这周重新恢复学习状态🤡🤡🤡（<del>自己都信了</del>）</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Q3，7-9月生活总结</title>
    <link href="/2021/09/29/newThink/"/>
    <url>/2021/09/29/newThink/</url>
    
    <content type="html"><![CDATA[<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><pre><code class="hljs">搬家了，离公司倒是近了不少，通勤一天一个小时，很满足。最近运动也少了，变胖不少呜呜呜呜；</code></pre><span id="more"></span><!-- more --><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li><p>测试驱动开发</p></li><li><p>Effective java</p></li><li><p>重构 改善及有代码的设计</p></li><li><p>java 8 实战（公司刚好有，就看了）</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">这几个月主要看的编码规范相关的书，还行编码时注意点更多了些，中间有个同事给别的同事 code_review 还能吵架的，<br>我直呼害怕，给别人 <span class="hljs-meta">code</span> review 都不敢提意见了，😅<br></code></pre></td></tr></table></figure><p>技术相关学习</p></li><li><p>python</p><blockquote><p>本来大学学了听多，不过工作一直没咋用，都忘完了，呜呜呜，又捡起来学了几天，不过最近中秋节一放假，又变成了纯纯的懒狗了😥</p></blockquote></li><li><p>go</p></li></ul><blockquote><p>啊，这么火的语言肯定要稍微学习一下，不过只是因为上个月有个前人留下来的 go 语言写的项目，花了半天把 go 相关语法学习了一下，确实比 java 优雅一些，不过也有挺恶心人的地方，</p><p>无穷多的 if err != nil 也是有点恶心，等后面工作要用的时候再深入学习吧，主要 go 语言和 java 对我来说功能重复了</p></blockquote><h2 id="Q4-期望"><a href="#Q4-期望" class="headerlink" title="Q4 期望"></a>Q4 期望</h2><h3 id="生活-1"><a href="#生活-1" class="headerlink" title="生活"></a>生活</h3><ul><li>减肥 10 斤（不想再胖了）</li><li>调整作息，减少熬夜（<del>我自己都不信</del>）</li></ul><h3 id="学习-1"><a href="#学习-1" class="headerlink" title="学习"></a>学习</h3><ul><li>多参与开源项目</li><li>python 学习深入</li><li>技术书籍保持一个月两本阅读量</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>偶尔发现 parallel 的小问题</title>
    <link href="/2021/09/17/parapell/"/>
    <url>/2021/09/17/parapell/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶尔发现的小问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 建立三个线程A、B、C 轮流线程打印ABC 简易版，</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABC1</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Integer num = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Object mutex = <span class="hljs-keyword">new</span> Object();<br><br>        Thread a = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                log.info(<span class="hljs-string">&quot;a进入循环&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (mutex) &#123;<br>                    log.info(<span class="hljs-string">&quot;a抢到锁&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">3000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;<br>                        log.info(<span class="hljs-string">&quot;a&quot;</span>);<br>                        num++;<br>                    &#125;<br><br>                &#125;<br>            &#125;<br>        &#125;);<br>        Thread b = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                log.info(<span class="hljs-string">&quot;b进入循环&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (mutex) &#123;<br>                    log.info(<span class="hljs-string">&quot;b抢到锁&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">3000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) &#123;<br>                        log.info(<span class="hljs-string">&quot;b&quot;</span>);<br>                        num++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        Thread c = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-comment">//这里 c 线程不打印日志</span><br>                <span class="hljs-keyword">synchronized</span> (mutex) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">3000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>) &#123;<br>                        log.info(<span class="hljs-string">&quot;c&quot;</span>);<br>                        num++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        a.start();<br>        b.start();<br>        c.start();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当时记得一句话，多线程里 sleep 一下能看到很多异常情况哈哈，😂<br>果然，这里 c 线程就少了两句 log 而已 ，抢到锁的概率大大提高，就有可能出现一两分钟 c 线程一直拿到锁<br>，不过不sleep的话概率会小很多，刚好从这里可以看出，synchronized  配合 wait 和 notify 的话，这种情况就可以避免了，<br>减少无用线程的空转</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技术</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机里小数如何保存的</title>
    <link href="/2021/09/10/float/"/>
    <url>/2021/09/10/float/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>今天没事的时候突然想起来一个经典问题，计算机里小数如何保存的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">float</span> b = <span class="hljs-number">0.70000000f</span>;<br><span class="hljs-keyword">float</span> c = <span class="hljs-number">0.69999999f</span>;<br>System.out.println(<span class="hljs-number">1</span>-<span class="hljs-number">0.9</span>);<br>System.out.println(b==c);<br></code></pre></td></tr></table></figure><p>结果为</p><blockquote><p>0.09999999999999998<br>true</p></blockquote><p>这些现象就和计算机如何保存小数的密不可分，哈哈😂😂，<br>首先是十进制小数如何转换为二进制</p><span id="more"></span><p>十进制小数转换成二进制小数采用”乘2取整，顺序排列”法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">如：<span class="hljs-number">0.625</span>=（<span class="hljs-number">0.101</span>）B<br><br><span class="hljs-number">0.625</span>*<span class="hljs-number">2</span>=<span class="hljs-number">1.25</span>======取出整数部分<span class="hljs-number">1</span><br><span class="hljs-number">0.25</span>*<span class="hljs-number">2</span>=<span class="hljs-number">0.5</span>========取出整数部分<span class="hljs-number">0</span><br><span class="hljs-number">0.5</span>*<span class="hljs-number">2</span>=<span class="hljs-number">1</span>==========取出整数部分<span class="hljs-number">1</span><br>再如：<span class="hljs-number">0.7</span>=（<span class="hljs-number">0.1</span> <span class="hljs-number">0110</span> <span class="hljs-number">0110.</span>..）B<br><br><span class="hljs-number">0.7</span>*<span class="hljs-number">2</span>=<span class="hljs-number">1.4</span>========取出整数部分<span class="hljs-number">1</span><br><span class="hljs-number">0.4</span>*<span class="hljs-number">2</span>=<span class="hljs-number">0.8</span>========取出整数部分<span class="hljs-number">0</span><br><span class="hljs-number">0.8</span>*<span class="hljs-number">2</span>=<span class="hljs-number">1.6</span>========取出整数部分<span class="hljs-number">1</span><br><span class="hljs-number">0.6</span>*<span class="hljs-number">2</span>=<span class="hljs-number">1.2</span>========取出整数部分<span class="hljs-number">1</span><br><span class="hljs-number">0.2</span>*<span class="hljs-number">2</span>=<span class="hljs-number">0.4</span>========取出整数部分<span class="hljs-number">0</span><br><span class="hljs-number">0.4</span>*<span class="hljs-number">2</span>=<span class="hljs-number">0.8</span>========取出整数部分<span class="hljs-number">0</span><br><span class="hljs-number">0.8</span>*<span class="hljs-number">2</span>=<span class="hljs-number">1.6</span>========取出整数部分<span class="hljs-number">1</span><br><span class="hljs-number">0.6</span>*<span class="hljs-number">2</span>=<span class="hljs-number">1.2</span>========取出整数部分<span class="hljs-number">1</span><br><span class="hljs-number">0.2</span>*<span class="hljs-number">2</span>=<span class="hljs-number">0.4</span>========取出整数部分<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>就像十进制不能表示 1/3 这样，1/10 二进制也不能完美表示，<br>再精度范围外就会有数据丢失，所以1 - 0.9 得到的确实上面的数据</p><p>再来看看float存储方式</p><p>首先我们知道常用科学计数法是将所有的数字转换成(±)a.b x 1 0 c 10^c10<br>c<br>的形式，其中a的范围是1到9共9个整数，b是小数点后的所有数字，c是10的指数。而计算机中存储的都是二进制数据，所以float存储的数字都要先转化成(±)a.b x 2 c 2^c2<br>c<br>，由于二进制中最大的数字就是1，所以表示法可以写成(±)1.b x 2 c 2^c2<br>c<br>的形式，float要想存储小数就只需要存储(±)，b和c就可以了。</p><p>float的存储正是将4字节32位划分为了3部分来分别存储正负号，小数部分和指数部分的：</p><p>Sign（1位）：用来表示浮点数是正数还是负数，0表示正数，1表示负数。<br>Exponent（8位）：指数部分。即上文提到数字c，但是这里不是直接存储c，为了同时表示正负指数以及他们的大小顺序，这里实际存储的是c+127。<br>Mantissa（23位）：尾数部分。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21年阅读书籍总结（待续）</title>
    <link href="/2021/09/09/book/"/>
    <url>/2021/09/09/book/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>今年看了不少书，也没总结，忘了从哪里看的一句话</p><blockquote><p>读书不总结 就等于没读</p></blockquote><p>所以为了没有白读书来总结一下 😂😂😂</p><h3 id="技术相关"><a href="#技术相关" class="headerlink" title="技术相关"></a>技术相关</h3><ul><li><p>《人月神话》</p><blockquote><p>印象最深的是这句： 当一份工作因具有连续性的限制而不可切分时，就算投入再多的人力，也不会对时程有所影响，生小孩就是需要九个月，你叫多少个妈一起生都一样，<br>软件工程就是像这样的工作，因为它必须调试，而调试本身就具有连续性的本质。</p></blockquote></li><li><p>《重构 改善既有代码的设计》</p><blockquote><p>总结：看到有坏味道的代码就立刻着手重构，否则破窗效应马上就会在整个项目里应验😂</p></blockquote></li><li><p>《人件》</p><blockquote><p>总结： 一本将管理的书，理解团队之间用于沟通合作成本还是很高的，不过目前好像我这个 level 暂时还用不到这些管理知识😒</p></blockquote></li><li><p>《测试驱动开发》</p><blockquote><p>了解了一下从先测试着手开发，对重构和代码质量确实可以提供很多好处，可惜项目中工期要求，一直难于实践 TDD 开发</p></blockquote></li></ul><p>其他很多书忘了，下次有机会再补齐吧🚀</p><blockquote><p>10月19日 更新 </p><p>准备接下来看这几本 《代码大全》《你的灯亮着吗》《现代操作系统》(强推)，《深入理解计算机系统》《程序员修炼之道:从小工到专家》<br>《 计算机程序的构造和解释》编程珠玑 《失控》<br>《TCPIP详解三部曲》、《图解HTTP》、《图解TCPIP》<br>哈哈，好像挺多的，慢慢看吧😂</p></blockquote><blockquote><p>12月22日 更新</p><p>最近一个人顶一个项目有点忙，后面闲下来准备看看周大佬的 《凤凰架构》</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>书籍</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>code review 注意事项</title>
    <link href="/2021/09/09/code-review/"/>
    <url>/2021/09/09/code-review/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>似乎有段时间没写博客了，没事总结一下编码规范，和code review一般需要注意的地方<br>。</p><blockquote><p>你的代码应该是写给下一个开发者的情书。</p></blockquote><p>看到这句话我深以为然，不过对面写不完的需求只能是尽力而为保持代码质量了，😂😂😂</p><span id="more"></span><h3 id="常规检查"><a href="#常规检查" class="headerlink" title="常规检查"></a>常规检查</h3><ul><li>目录设置是否合理、模块划分是否清晰、代码结构是否满足“高內聚、松耦合”?</li><li>是否遵循经典的设计原则和设计思想(SOLD、DRY、KSS、YAGN、LOD等)?</li><li>设计模式是否应用得当?是否有过度设计?</li><li>代码是否容易扩展?如果要添加新功能,是否容易实现?</li><li>代码是否可以复用?是否可以复用已有的项目代码或类库?是否有重复造轮子?</li><li>代码是否容易测试?单元测试是否全面覆盖各种正常和异常的情况?</li><li>代码是否易读?是否符合编码规范(比如命名和注释是否恰当、代码风格是否一致等)?</li></ul><h3 id="业务需求角度"><a href="#业务需求角度" class="headerlink" title="业务需求角度"></a>业务需求角度</h3><ul><li>代码是否实现了预期的业务需求?</li><li>逻辑是否正确?是否处理了各种异常情况?</li><li>日志打印是否得当?是否方便 debug排查问题?</li><li>接口是否易用?是否支持幂等、事务等?</li><li>代码是否存在并发问题?是否线程安全?</li><li>性能是否有优化空间,比如,SQL、算法是否可以优化?</li><li>是否有安全漏洞?比如,输入输出校验是否全面?</li></ul><h3 id="可读性，扩展性，性能的取舍"><a href="#可读性，扩展性，性能的取舍" class="headerlink" title="可读性，扩展性，性能的取舍"></a>可读性，扩展性，性能的取舍</h3><p>对于一般项目，我个人认为 扩展性 &gt; 可读性 &gt; 性能， 性能其实一般出现瓶颈的时候我们在特地优化即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技术</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Apache httpclient 并发请求时的注意设置</title>
    <link href="/2021/08/23/resttemplate/"/>
    <url>/2021/08/23/resttemplate/</url>
    
    <content type="html"><![CDATA[<h1 id="Apache-httpclient-并发请求时的注意设置"><a href="#Apache-httpclient-并发请求时的注意设置" class="headerlink" title="Apache httpclient 并发请求时的注意设置"></a>Apache httpclient 并发请求时的注意设置</h1><p>还是前几天并发请求的需求，当时发现测试里直接开十个线程请求，比项目里请求要快上一倍，</p><p>俺直呼不对劲不对劲，哈哈哈哈，第一时间想到用的 restTemplate 底层用到了线程池，但是并没有十个同时进行，所以排队请求，耗时多了一倍，</p><p>后面发现项目里 restTemplate 用的 Apache httpclient，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientHttpRequestFactory <span class="hljs-title">buildClientHttpRequestFactory</span><span class="hljs-params">()</span></span>&#123;<br>       ...<br>       PoolingHttpClientConnectionManager phccm = <span class="hljs-keyword">new</span> PoolingHttpClientConnectionManager(registry);<br>    <span class="hljs-comment">//  这里是线程池里所有线程数</span><br>       phccm.setMaxTotal(<span class="hljs-number">200</span>);<br>       <span class="hljs-comment">//phccm.setDefaultMaxPerRoute(10);  之前没有加上</span><br>        CloseableHttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).setConnectionManager(phccm).setConnectionManagerShared(<span class="hljs-keyword">true</span>).build();<br>       factory.setHttpClient(httpClient);<br>       <span class="hljs-keyword">return</span> factory;<br>   &#125;<br></code></pre></td></tr></table></figure><p>DefaultMaxPerRoute 意思是某一个服务每次能并行接收的请求数量，点进源码一看，默认并行请求数量为  2，怪不得项目里这么慢。哈哈哈，后面就加上了<code>phccm.setDefaultMaxPerRoute(10); </code>，再进行测试，耗时少了一倍，心满意足🤣</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并行stream流使用注意</title>
    <link href="/2021/08/19/parallel/"/>
    <url>/2021/08/19/parallel/</url>
    
    <content type="html"><![CDATA[<h1 id="并行stream流使用注意"><a href="#并行stream流使用注意" class="headerlink" title="并行stream流使用注意"></a>并行stream流使用注意</h1><p>​    今天项目中有个地方需要并发调用别的接口，同事推荐我用 stream 的 parallel 流去进行并行操作，使用起来确实很简单，但是使用 stream 的 parallel 流 项目所有流操作都是共享该池，当频繁的用于阻塞型任务（IO流：http请求等）时会导致整个项目卡顿，所以说parallelStream只适用于cpu密集型的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool(<span class="hljs-number">3</span>);<br>        forkJoinPool.submit(() -&gt; &#123;<br>            Stream.of(firstRange).parallel().forEach((number) -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;任务1的线程:&quot;</span> + Thread.currentThread().getName());<br>                    <span class="hljs-comment">// do something slow</span><br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;);<br>        &#125;);<br></code></pre></td></tr></table></figure><p>这样指定的话就没问题了，不过最后还是使用了  CompletableFuture 配合自定义线程池去使用，主要是 CompletableFuture 更灵活哈哈哈哈哈😏</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springMvc 参数下划线驼峰解析</title>
    <link href="/2021/08/16/jsonInfo/"/>
    <url>/2021/08/16/jsonInfo/</url>
    
    <content type="html"><![CDATA[<h1 id="springMvc-参数下划线驼峰解析"><a href="#springMvc-参数下划线驼峰解析" class="headerlink" title="springMvc 参数下划线驼峰解析"></a>springMvc 参数下划线驼峰解析</h1><p>今天突然有个需求，有个接口对应请求参数都是下划线为分割点，</p><p>虽然有 <code>@JsonProperty</code> 可以去一一对应，但是整个类弄下来就很麻烦，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@JsonNaming(<span class="hljs-params">value = PropertyNamingStrategy.SnakeCaseStrategy.<span class="hljs-keyword">class</span></span>)</span><br></code></pre></td></tr></table></figure><p>后来找到这个，在实体类上配好，就不用一一去对应了，还是很方便的😂</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea冷门知识</title>
    <link href="/2021/08/10/idea/"/>
    <url>/2021/08/10/idea/</url>
    
    <content type="html"><![CDATA[<h2 id="idea冷门知识"><a href="#idea冷门知识" class="headerlink" title="idea冷门知识"></a>idea冷门知识</h2><p>今天突然意外的发现了 idea 的冷门知识，😂</p><p>当一个类里的方法很多的时候，可能希望能分类查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// region foo</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doSomthing</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-number">123</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><span class="hljs-comment">// endregion foo</span><br></code></pre></td></tr></table></figure><p>这样子写，ctrl + F12 就可以看到如下效果</p><p><img src="https://files.catbox.moe/xtwmjs.png"></p><p>还是个挺实用的冷门知识 ，哈哈哈</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何求一个 int length 多长？</title>
    <link href="/2021/07/23/getIntLength/"/>
    <url>/2021/07/23/getIntLength/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>没错，又是看到 Integer 里的代码，</p><p>如何求一个 int length多长🤔🤔</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> [] sizeTable = &#123; <span class="hljs-number">9</span>, <span class="hljs-number">99</span>, <span class="hljs-number">999</span>, <span class="hljs-number">9999</span>, <span class="hljs-number">99999</span>, <span class="hljs-number">999999</span>, <span class="hljs-number">9999999</span>,<br>                                      <span class="hljs-number">99999999</span>, <span class="hljs-number">999999999</span>, Integer.MAX_VALUE &#125;;<br><br><span class="hljs-comment">// Requires positive x</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">stringSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; ; i++)<br>        <span class="hljs-keyword">if</span> (x &lt;= sizeTable[i])<br>            <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>没想到有时候开发 jdk 大神们的思路又是如此的奇清😂😂</p><h3 id="32进制内求进制字符串"><a href="#32进制内求进制字符串" class="headerlink" title="32进制内求进制字符串"></a>32进制内求进制字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * All possible chars for representing a number as a String</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] digits = &#123;<br>        <span class="hljs-string">&#x27;0&#x27;</span> , <span class="hljs-string">&#x27;1&#x27;</span> , <span class="hljs-string">&#x27;2&#x27;</span> , <span class="hljs-string">&#x27;3&#x27;</span> , <span class="hljs-string">&#x27;4&#x27;</span> , <span class="hljs-string">&#x27;5&#x27;</span> ,<br>        <span class="hljs-string">&#x27;6&#x27;</span> , <span class="hljs-string">&#x27;7&#x27;</span> , <span class="hljs-string">&#x27;8&#x27;</span> , <span class="hljs-string">&#x27;9&#x27;</span> , <span class="hljs-string">&#x27;a&#x27;</span> , <span class="hljs-string">&#x27;b&#x27;</span> ,<br>        <span class="hljs-string">&#x27;c&#x27;</span> , <span class="hljs-string">&#x27;d&#x27;</span> , <span class="hljs-string">&#x27;e&#x27;</span> , <span class="hljs-string">&#x27;f&#x27;</span> , <span class="hljs-string">&#x27;g&#x27;</span> , <span class="hljs-string">&#x27;h&#x27;</span> ,<br>        <span class="hljs-string">&#x27;i&#x27;</span> , <span class="hljs-string">&#x27;j&#x27;</span> , <span class="hljs-string">&#x27;k&#x27;</span> , <span class="hljs-string">&#x27;l&#x27;</span> , <span class="hljs-string">&#x27;m&#x27;</span> , <span class="hljs-string">&#x27;n&#x27;</span> ,<br>        <span class="hljs-string">&#x27;o&#x27;</span> , <span class="hljs-string">&#x27;p&#x27;</span> , <span class="hljs-string">&#x27;q&#x27;</span> , <span class="hljs-string">&#x27;r&#x27;</span> , <span class="hljs-string">&#x27;s&#x27;</span> , <span class="hljs-string">&#x27;t&#x27;</span> ,<br>        <span class="hljs-string">&#x27;u&#x27;</span> , <span class="hljs-string">&#x27;v&#x27;</span> , <span class="hljs-string">&#x27;w&#x27;</span> , <span class="hljs-string">&#x27;x&#x27;</span> , <span class="hljs-string">&#x27;y&#x27;</span> , <span class="hljs-string">&#x27;z&#x27;</span><br>    &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">toString</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> radix)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX)<br>        radix = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">/* Use the faster version */</span><br>    <span class="hljs-keyword">if</span> (radix == <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">return</span> toString(i);<br>    &#125;<br><br>    <span class="hljs-keyword">char</span> buf[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">33</span>];<br>    <span class="hljs-keyword">boolean</span> negative = (i &lt; <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> charPos = <span class="hljs-number">32</span>;<br><br>    <span class="hljs-keyword">if</span> (!negative) &#123;<br>        i = -i;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= -radix) &#123;<br>        buf[charPos--] = digits[-(i % radix)];<br>        i = i / radix;<br>    &#125;<br>    buf[charPos] = digits[-i];<br><br>    <span class="hljs-keyword">if</span> (negative) &#123;<br>        buf[--charPos] = <span class="hljs-string">&#x27;-&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buf, charPos, (<span class="hljs-number">33</span> - charPos));<br>&#125;<br></code></pre></td></tr></table></figure><p>和之前求 int 长度的方法有异曲同工之妙，哈哈哈哈</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技术</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>int 和字符串操作的思考</title>
    <link href="/2021/07/23/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2021/07/23/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>今天写代码的时候，看到了一些 int 和 stirng 类型数据相加的操作，想到了一些小问题🤔</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String a = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">int</span> b = -<span class="hljs-number">123</span>;<br>String strB = Integer.toString(b);<br>String strC = a + b;<br></code></pre></td></tr></table></figure><h3 id="Integer-toString-内部方法"><a href="#Integer-toString-内部方法" class="headerlink" title="Integer.toString()内部方法"></a>Integer.toString()内部方法</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static String <span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">int</span> <span class="hljs-params">i</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i<span class="hljs-operator"> == </span>Integer.MIN_VALUE)<br>            return <span class="hljs-string">&quot;-2147483648&quot;</span>;<br>        <span class="hljs-built_in">int</span> size = (i &lt; <span class="hljs-number">0</span>) ? <span class="hljs-built_in">string</span><span class="hljs-constructor">Size(-<span class="hljs-params">i</span>)</span> + <span class="hljs-number">1</span> : <span class="hljs-built_in">string</span><span class="hljs-constructor">Size(<span class="hljs-params">i</span>)</span>;<br>        <span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span><span class="hljs-literal">[<span class="hljs-identifier">size</span>]</span>;<br>        get<span class="hljs-constructor">Chars(<span class="hljs-params">i</span>, <span class="hljs-params">size</span>, <span class="hljs-params">buf</span>)</span>;<br>        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">buf</span>, <span class="hljs-params">true</span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>思考为何 <code> &quot;&quot;+ int</code> 能完成为何这种还存在，</p><p>想了想，String相加的时候，内部转换应该也是用了一样的方法，众所周知，</p><p>字符串相加会自动优化成 <code>StringBuild</code> 操作，</p><h3 id="StringBuilder-方法"><a href="#StringBuilder-方法" class="headerlink" title="StringBuilder 方法"></a>StringBuilder 方法</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>  public StringBuilder append(<span class="hljs-built_in">int</span> i) &#123;<br>      super.append(i);<br>      return this;<br>  &#125;<br>  <br>  ====================<br>  点进super进去<br>  ====================<br>  <br>   public AbstractStringBuilder append(<span class="hljs-built_in">int</span> i) &#123;<br>      <span class="hljs-keyword">if</span> (i<span class="hljs-operator"> == </span>Integer.MIN_VALUE) &#123;<br>          append(<span class="hljs-string">&quot;-2147483648&quot;</span>);<br>          return this;<br>      &#125;<br>      <span class="hljs-built_in">int</span> appendedLength = (i &lt; <span class="hljs-number">0</span>) ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span><span class="hljs-built_in">string</span><span class="hljs-constructor">Size(-<span class="hljs-params">i</span>)</span> + <span class="hljs-number">1</span><br>                                   : <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span><span class="hljs-built_in">string</span><span class="hljs-constructor">Size(<span class="hljs-params">i</span>)</span>;<br>      <span class="hljs-built_in">int</span> spaceNeeded = count + appendedLength;<br>      ensure<span class="hljs-constructor">CapacityInternal(<span class="hljs-params">spaceNeeded</span>)</span>;<br>      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>get<span class="hljs-constructor">Chars(<span class="hljs-params">i</span>, <span class="hljs-params">spaceNeeded</span>, <span class="hljs-params">value</span>)</span>;<br>      count = spaceNeeded;<br>      return this;<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>果然，和 Integer里的方法基本一个道理，🤣🤣🤣🤣🤣</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技术</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/09/helloWord/"/>
    <url>/2021/07/09/helloWord/</url>
    
    <content type="html"><![CDATA[<h2 id="Hello-World，终极拖延症的第一篇博客"><a href="#Hello-World，终极拖延症的第一篇博客" class="headerlink" title="Hello World，终极拖延症的第一篇博客"></a>Hello World，终极拖延症的第一篇博客</h2><p>作为一个技术人员，没有自己的博客太不像话了，哈哈哈哈😂😂😂😂😂。</p><p>准备每半个月写一篇博客（自己差点都信了），🚀🚀🚀🚀</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
